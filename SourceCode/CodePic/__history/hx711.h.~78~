#ifndef HX711_H
#define HX711_H

// HX711 Pin Definitions
#define HX711_DT_PIN  PIN_A0
#define HX711_SCK_PIN PIN_A1

// --- Configuration Constants ---
// S? l?n g?i readCount() d? l?y trung bình trong m?t l?n g?i readAverageRawValue()
#define NUM_SAMPLES_PER_AVERAGE_CYCLE 30

// S? chu k? l?y trung bình (m?i chu k? là NUM_SAMPLES_PER_AVERAGE_CYCLE l?n d?c)
// du?c s? d?ng khi tare ho?c khi l?y giá tr? d? hi?n th?/tính toán.
// Tang giá tr? này d? tang d? ?n d?nh.
#define NUM_AVERAGE_CYCLES_FOR_READ 3 // T?ng s? l?n d?c thô = 3 * 30 = 90

// Ngu?ng ch?t cho giá tr? delta_raw (raw_value - OFFSET).
#define DEADZONE_RAW_DELTA 300

// --- Ch? d? ho?t d?ng ---
typedef enum {
    MODE_NORMAL_WEIGHT,       // Ch? d? ho?t d?ng bình thu?ng, tr? v? tr?ng lu?ng dã scale
    MODE_COLLECT_RAW_DATA     // Ch? d? thu th?p d? li?u, hx711_get_units tr? v? giá tr? thô trung bình
} HX711_OperationMode;

// Ð?T CH? Ð? HO?T Ð?NG ? ÐÂY:
static HX711_OperationMode current_hx711_mode = MODE_NORMAL_WEIGHT; // M?c d?nh
// Ð? thu th?p d? li?u, thay d?i thành: MODE_COLLECT_RAW_DATA và biên d?ch l?i.

// --- Global static variables ---
static long HX711_OFFSET = 0;
static double HX711_SCALE = 466.837; // Gi? giá tr? SCALE c?a b?n

// --- Function Prototypes ---
void hx711_init_pins(void);
unsigned int32 readCount_internal(void); // Ð?i tên d? tránh nh?m l?n n?u b?n có readCount ? main
long readAverageRawValue(int8 num_cycles);
void hx711_tare(int8 ignored_times); // Gi? nguyên signature cho main.c
float hx711_get_units(int8 ignored_times); // Gi? nguyên signature cho main.c

// Các hàm ti?n ích (b?n không g?i tr?c ti?p t? main.c hi?n t?i)
void hx711_set_mode(HX711_OperationMode mode);
HX711_OperationMode hx711_get_mode(void);
long hx711_get_current_offset(void);
void hx711_set_current_offset(long offset_val); // H?u ích n?u b?n mu?n khôi ph?c offset
void hx711_set_current_scale(double scale_val); // H?u ích n?u b?n mu?n khôi ph?c scale

// --- Function Implementations ---

void hx711_init_pins(void) {
    output_low(HX711_SCK_PIN);
}

// Ðã s?a l?i và thêm delay
unsigned int32 readCount_internal(void) {
    unsigned int32 data_value = 0;
    unsigned int8 i;
    unsigned int16 timeout_counter = 0;

    output_low(HX711_SCK_PIN); delay_us(1);
    while (input(HX711_DT_PIN)) {
        delay_us(1);
        if (++timeout_counter > 60000) return 0x7FFFFF; // Timeout
    }

    for (i = 0; i < 24; i++) {
        output_high(HX711_SCK_PIN); delay_us(1);
        data_value = data_value << 1;
        output_low(HX711_SCK_PIN); delay_us(1);
        if (input(HX711_DT_PIN)) data_value++;
    }

    output_high(HX711_SCK_PIN); delay_us(1);
    data_value = data_value ^ 0x800000;
    output_low(HX711_SCK_PIN); delay_us(1);
    return data_value;
}

// Ð?c trung bình c?a 'num_cycles' l?n, m?i l?n là trung bình c?a 'NUM_SAMPLES_PER_AVERAGE_CYCLE' giá tr? thô.
long readAverageRawValue(int8 num_cycles) {
    long-long total_sum = 0; // S? d?ng long-long d? tránh tràn khi num_cycles l?n
    if (num_cycles < 1) num_cycles = 1;

    for (int8 cycle = 0; cycle < num_cycles; cycle++) {
        unsigned int32-OR-long cycle_sum = 0; // S?a ki?u d? li?u c?a cycle_sum
        for (int8 k = 0; k < NUM_SAMPLES_PER_AVERAGE_CYCLE; k++) {
            cycle_sum += readCount_internal();
        }
        total_sum += (cycle_sum / NUM_SAMPLES_PER_AVERAGE_CYCLE);
        if (num_cycles > 1 && cycle < (num_cycles - 1)) {
            delay_ms(5); // Delay nh? gi?a các chu k? l?y average l?n
        }
    }
    return (long)(total_sum / num_cycles);
}


// Hàm tare du?c g?i t? main.c
void hx711_tare(int8 ignored_times) {
   HX711_OFFSET = readAverageRawValue(NUM_AVERAGE_CYCLES_FOR_READ);
}

// Hàm get_units du?c g?i t? main.c
float hx711_get_units(int8 ignored_times) {
    if (current_hx711_mode == MODE_COLLECT_RAW_DATA) {
        // Ch? d? thu th?p d? li?u thô: tr? v? giá tr? thô trung bình
        return (float)readAverageRawValue(NUM_AVERAGE_CYCLES_FOR_READ);
    } else {
        // Ch? d? ho?t d?ng bình thu?ng:
        long raw_avg_value = readAverageRawValue(NUM_AVERAGE_CYCLES_FOR_READ);
        long delta = raw_avg_value - HX711_OFFSET;

        if (delta < DEADZONE_RAW_DELTA && delta > -DEADZONE_RAW_DELTA) {
            delta = 0;
        }
        if (HX711_SCALE == 0.0) return 0.0; // Tránh chia cho 0
        
        float weight = (float)delta / HX711_SCALE;
        // Không c?n if (weight < 0) weight = 0; n?u deadzone và logic sau này x? lý t?t
        // if (weight > 99999) weight = 99999; // Gi? gi?i h?n c?a b?n
        return weight;
    }
}

// --- Các hàm ti?n ích ---
void hx711_set_mode(HX711_OperationMode mode) {
    current_hx711_mode = mode;
}

HX711_OperationMode hx711_get_mode(void) {
    return current_hx711_mode;
}

long hx711_get_current_offset(void) {
    return HX711_OFFSET;
}

void hx711_set_current_offset(long offset_val){
    HX711_OFFSET = offset_val;
}

void hx711_set_current_scale(double scale_val){
    HX711_SCALE = scale_val;
}

// Các hàm calibrate và set_scale g?c c?a b?n có th? du?c gi? l?i n?u b?n v?n mu?n dùng chúng
// theo cách cu, nhung chúng s? không tuong thích hoàn toàn v?i logic da di?m sau này.
// void hx711_set_scale(double scale) { SCALE = scale; }
// void hx711_calibrate(float known_weight) { ... }

#endif // HX711_H
