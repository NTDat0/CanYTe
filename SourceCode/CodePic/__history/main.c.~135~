#include <16F877A.h>
#fuses HS,NOWDT,NOPROTECT,NOLVP
#use delay(clock=8000000)
#use fast_io(D)
#use fast_io(C)
#use fast_io(B)
#use standard_io(A)

#include "lcd.h"
#include "max30102.h"
#include "dht11.h"
#include "hx711.h"

// Enhanced display function with better formatting
void display_number(int32 num, int8 pos, int8 digits) {
   if (num < 0) num = 0; // Ensure non-negative
   if (num > 99 && digits == 2) num = 99;
   if (num > 999 && digits == 3) num = 999;
   if (num > 99999 && digits == 5) num = 99999;

   LCD_SetPosition(pos);
   
   if (digits == 2) {
      LCD_PutChar((num / 10) + '0');
      LCD_PutChar((num % 10) + '0');
   } 
   else if (digits == 3) {
      if (num >= 100) {
         LCD_PutChar((num / 100) + '0');
         LCD_PutChar(((num % 100) / 10) + '0');
         LCD_PutChar((num % 10) + '0');
      } else if (num >= 10) {
         LCD_PutChar(' ');
         LCD_PutChar((num / 10) + '0');
         LCD_PutChar((num % 10) + '0');
      } else {
         LCD_PutChar(' ');
         LCD_PutChar(' ');
         LCD_PutChar(num + '0');
      }
   }
   else if (digits == 5) {
      // Enhanced 5-digit display with better alignment
      int32 temp = num;
      int8 digit_array[5];
      int8 i;
      
      // Extract digits
      for (i = 4; i >= 0; i--) {
         digit_array[i] = temp % 10;
         temp /= 10;
      }
      
      // Display with proper spacing
      int1 leading_zero = 1;
      for (i = 0; i < 5; i++) {
         if (digit_array[i] != 0 || i == 4) { // Always show last digit
            leading_zero = 0;
         }
         
         if (leading_zero && i < 4) {
            LCD_PutChar(' ');
         } else {
            LCD_PutChar(digit_array[i] + '0');
         }
      }
   }
   delay_us(20);
}

// Enhanced initialization with error checking
int1 system_init() {
   // Port configuration
   set_tris_d(0x00); // LCD on PORTD (output)
   set_tris_c(0x00); // PORTC for I2C (MAX30102) 
   set_tris_b(0xFF); // PORTB as input (for DHT11)
   set_tris_a(0x01); // A0 input for HX711 DT, A1 output for HX711 SCK
   
   // Clear all ports
   output_d(0x00);
   output_c(0x00);
   output_a(0x00);
   
   // Initialize LCD with retry
   LCD_Init();
   delay_ms(100);
   
   // Test LCD
   LCD_SetPosition(LINE_1);
   LCD_PutChar('I'); LCD_PutChar('n'); LCD_PutChar('i'); LCD_PutChar('t'); LCD_PutChar('.');LCD_PutChar('.');LCD_PutChar('.');
   delay_ms(500);
   
   // Initialize MAX30102 with retry
   int8 max_retry = 3;
   while (max_retry > 0) {
      max30102_init();
      delay_ms(100);
      // Test I2C communication
      if (max30102_test_connection()) {
         break;
      }
      max_retry--;
      delay_ms(200);
   }
   
   // Initialize HX711 with stabilization
   for (int8 i = 0; i < 10; i++) {
      readCount();
      delay_ms(50);
   }
   
   // Multi-point tare for better accuracy
   hx711_tare(5);
   delay_ms(100);
   
   return (max_retry > 0); // Return success status
}

void main() {
   // System initialization
   if (!system_init()) {
      // Error handling - display error message
      LCD_SetPosition(LINE_1);
      LCD_PutChar('E'); LCD_PutChar('R'); LCD_PutChar('R'); LCD_PutChar('O'); LCD_PutChar('R');
      while(1) delay_ms(1000); // Halt on error
   }
   
   // Reset all sensor values
   hr_value = 0;
   spo2_value = 0;
   finger_detected = 0;
   hr_update_counter = 0;
   spo2_update_counter = 0;
   
   // Clear LCD and display static labels
   LCD_Clear();
   delay_ms(50);
   
   // Display static labels with better formatting
   LCD_SetPosition(LINE_1); // Line 1: Temp and Humidity  
   LCD_PutChar('T'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('C'); 
   LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); 
   LCD_PutChar('H'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('%');
   
   LCD_SetPosition(LINE_2); // Line 2: HR
   LCD_PutChar('H'); LCD_PutChar('R'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); 
   LCD_PutChar('b'); LCD_PutChar('p'); LCD_PutChar('m');
   
   LCD_SetPosition(LINE_3); // Line 3: SpO2
   LCD_PutChar('S'); LCD_PutChar('p'); LCD_PutChar('O'); LCD_PutChar('2'); LCD_PutChar(':'); 
   LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('%');
   
   LCD_SetPosition(LINE_4); // Line 4: Weight
   LCD_PutChar('W'); LCD_PutChar('e'); LCD_PutChar('i'); LCD_PutChar('g'); LCD_PutChar('h'); LCD_PutChar('t'); LCD_PutChar(':'); 
   LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('g');

   // Enhanced timing system with independent counters
   int8 max30102_counter = 0;   // Fast: every 20ms  
   int8 dht11_counter = 0;      // Slow: every 2000ms (2s)
   int8 hx711_counter = 0;      // Medium: every 200ms
   int8 display_counter = 0;    // Display: every 500ms
   int8 system_counter = 0;     // System maintenance: every 10s
   
   // Sensor data variables
   unsigned int8 temp = 0, temp_prev = 0;
   unsigned int8 hum = 0, hum_prev = 0;
   int32 weight_raw = 0, weight_filtered = 0;
   int32 weight_buffer[5] = {0,0,0,0,0}; // Moving average buffer
   int8 weight_buf_index = 0;
   
   // Error counters for stability
   int8 dht11_error_count = 0;
   int8 max30102_error_count = 0;
   int8 hx711_error_count = 0;
   
   while (TRUE) {
      // MAX30102 - High frequency sampling (20ms)
      if (max30102_counter == 0) {
         if (max30102_read_and_process()) {
            max30102_error_count = 0;
         } else {
            max30102_error_count++;
            if (max30102_error_count > 10) {
               hr_value = 0;
               spo2_value = 0;
               finger_detected = 0;
            }
         }
      }
      max30102_counter = (max30102_counter + 1) % 4; // 20ms

      // DHT11 - Low frequency sampling (2000ms)
      if (dht11_counter == 0) {
         if (dht11_read(&temp, &hum)) {
            dht11_error_count = 0;
            temp_prev = temp;
            hum_prev = hum;
         } else {
            dht11_error_count++;
            if (dht11_error_count < 5) {
               temp = temp_prev; // Use previous valid data
               hum = hum_prev;
            }
         }
      }
      dht11_counter = (dht11_counter + 1) % 400; // 2000ms

      // HX711 - Medium frequency with moving average (200ms)
      if (hx711_counter == 0) {
         weight_raw = hx711_get_weight_filtered();
         if (weight_raw >= 0) {
            // Moving average filter
            weight_buffer[weight_buf_index] = weight_raw;
            weight_buf_index = (weight_buf_index + 1) % 5;
            
            // Calculate filtered weight
            int32 weight_sum = 0;
            for (int8 i = 0; i < 5; i++) {
               weight_sum += weight_buffer[i];
            }
            weight_filtered = weight_sum / 5;
            hx711_error_count = 0;
         } else {
            hx711_error_count++;
         }
      }
      hx711_counter = (hx711_counter + 1) % 40; // 200ms

      // Display update (500ms)
      if (display_counter == 0) {
         display_number(temp, LINE_1 + 3, 2);
         display_number(hum, LINE_1 + 10, 2);
         display_number(hr_value, LINE_2 + 3, 3);
         display_number(spo2_value, LINE_3 + 5, 3);
         display_number(weight_filtered, LINE_4 + 7, 5);
      }
      display_counter = (display_counter + 1) % 100; // 500ms

      // System maintenance (10s)
      if (system_counter == 0) {
         // Periodic system health check
         if (max30102_error_count > 20) {
            max30102_init(); // Reinitialize if too many errors
            max30102_error_count = 0;
         }
         
         if (hx711_error_count > 10) {
            hx711_tare(1); // Re-tare if unstable
            hx711_error_count = 0;
         }
         
         // Watchdog equivalent - reset error counters
         dht11_error_count = 0;
      }
      system_counter = (system_counter + 1) % 2000; // 10000ms

      delay_ms(5); // Base 5ms timing
   }
}
