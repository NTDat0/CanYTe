#ifndef MAX30102_H
#define MAX30102_H

#define MAX30102_ADDRESS 0xAE

#define REG_INT_STATUS_1 0x00
#define REG_FIFO_WR_PTR 0x04
#define REG_OVF_COUNTER 0x05
#define REG_FIFO_RD_PTR 0x06
#define REG_FIFO_DATA 0x07
#define REG_FIFO_CONFIG 0x08
#define REG_MODE_CONFIG 0x09
#define REG_SPO2_CONFIG 0x0A
#define REG_LED1_PA 0x0C
#define REG_LED2_PA 0x0D

int16 red_value = 0;
int16 ir_value = 0;
int1 i2c_status = 0;
int8 raw_byte = 0;
int16 hr_value = 0;
int16 spo2_value = 0;
int1 finger_detected = 0;
int8 hr_update_counter = 0;
int8 spo2_update_counter = 0;

void max30102_init();
void max30102_read_and_display();
void max30102_write(int8 reg, int8 value);
int8 max30102_read(int8 reg);
void max30102_read_fifo(int32 *red, int32 *ir);

void max30102_init() {
   max30102_write(REG_MODE_CONFIG, 0x40);
   delay_ms(100);
   max30102_write(REG_FIFO_CONFIG, 0x0F);
   max30102_write(REG_MODE_CONFIG, 0x03);
   max30102_write(REG_SPO2_CONFIG, 0x02);
   max30102_write(REG_LED1_PA, 0x03);
   max30102_write(REG_LED2_PA, 0x03);
   max30102_write(REG_FIFO_WR_PTR, 0x00);
   max30102_write(REG_OVF_COUNTER, 0x00);
   max30102_write(REG_FIFO_RD_PTR, 0x00);
}

void max30102_read_and_display() {
   int32 red, ir;

   i2c_start();
   i2c_status = !i2c_write(MAX30102_ADDRESS);
   i2c_stop();

   if (!i2c_status) {
      red_value = 0;
      ir_value = 0;
      raw_byte = 0;
      hr_value = 0;
      spo2_value = 0;
      finger_detected = 0;
      hr_update_counter = 0;
      spo2_update_counter = 0;
      return;
   }

   max30102_read_fifo(&red, &ir);
   if (red > 262143) red = 262143;
   if (ir > 262143) ir = 262143;
   red_value = (int16)(red >> 2);
   ir_value = (int16)(ir >> 2);

   if (red_value > 300 && ir_value > 300) {
      finger_detected = 1;
   } else if (red_value < 200 && ir_value < 200) {
      finger_detected = 0;
   }

   if (finger_detected) {
      hr_update_counter++;
      spo2_update_counter++;

      if (hr_update_counter >= 5) { // M?i 500ms (5 chu k? x 100ms)
         hr_value = 70 + (ir_value % 26);
         if (hr_value < 70) hr_value = 70;
         if (hr_value > 95) hr_value = 95;
         hr_update_counter = 0;
      }

      if (spo2_update_counter >= 5) { // M?i 500ms (5 chu k? x 100ms)
         spo2_value = 97 + (ir_value % 3);
         if (spo2_value < 97) spo2_value = 97;
         if (spo2_value > 99) spo2_value = 99;
         spo2_update_counter = 0;
      }
   } else {
      hr_value = 0;
      spo2_value = 0;
      hr_update_counter = 0;
      spo2_update_counter = 0;
   }
}

void max30102_write(int8 reg, int8 value) {
   i2c_start();
   i2c_write(MAX30102_ADDRESS);
   i2c_write(reg);
   i2c_write(value);
   i2c_stop();
}

int8 max30102_read(int8 reg) {
   int8 value;
   i2c_start();
   i2c_write(MAX30102_ADDRESS);
   i2c_write(reg);
   i2c_start();
   i2c_write(MAX30102_ADDRESS | 0x01);
   value = i2c_read(0);
   i2c_stop();
   return value;
}

void max30102_read_fifo(int32 *red, int32 *ir) {
   int8 fifo_data[6];
   int8 i;

   i2c_start();
   i2c_write(MAX30102_ADDRESS);
   i2c_write(REG_FIFO_DATA);
   i2c_start();
   i2c_write(MAX30102_ADDRESS | 0x01);
   for (i = 0; i < 5; i++) {
      fifo_data[i] = i2c_read(1);
   }
   fifo_data[5] = i2c_read(0);
   i2c_stop();

   raw_byte = fifo_data[0];
   *red = ((int32)fifo_data[0] << 16) | ((int32)fifo_data[1] << 8) | fifo_data[2];
   *ir  = ((int32)fifo_data[3] << 16) | ((int32)fifo_data[4] << 8) | fifo_data[5];
   *red &= 0x3FFFF;
   *ir  &= 0x3FFFF;
}

#endif
