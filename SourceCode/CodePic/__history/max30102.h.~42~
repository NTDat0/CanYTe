#ifndef MAX30102_H
#define MAX30102_H

#use i2c(Master, SDA=PIN_C4, SCL=PIN_C3, SLOW=100000)

// MAX30102 I2C address
#define MAX30102_ADDRESS 0xAE

// MAX30102 Registers
#define REG_INT_STATUS_1 0x00
#define REG_INT_STATUS_2 0x01
#define REG_INT_ENABLE_1 0x02
#define REG_INT_ENABLE_2 0x03
#define REG_FIFO_WR_PTR 0x04
#define REG_OVF_COUNTER 0x05
#define REG_FIFO_RD_PTR 0x06
#define REG_FIFO_DATA 0x07
#define REG_FIFO_CONFIG 0x08
#define REG_MODE_CONFIG 0x09
#define REG_SPO2_CONFIG 0x0A
#define REG_LED1_PA 0x0C
#define REG_LED2_PA 0x0D
#define REG_LED3_PA 0x0E
#define REG_PILOT_PA 0x10
#define REG_MULTI_LED_CTRL1 0x11
#define REG_MULTI_LED_CTRL2 0x12
#define REG_TEMP_INT 0x1F
#define REG_TEMP_FRAC 0x20
#define REG_DIE_TEMP_CONFIG 0x21
#define REG_REVISION_ID 0xFE
#define REG_PART_ID 0xFF

// Signal processing constants  
#define SIGNAL_BUFFER_SIZE 32
#define PEAK_DETECTION_THRESHOLD 100
#define MIN_HEART_RATE 50
#define MAX_HEART_RATE 180
#define MIN_SPO2 85
#define MAX_SPO2 100

// Global variables
int16 red_value = 0;
int16 ir_value = 0;
int1 i2c_status = 0;
int8 raw_byte = 0;
int16 hr_value = 0;
int16 spo2_value = 0;
int1 finger_detected = 0;
int8 hr_update_counter = 0;
int8 spo2_update_counter = 0;
int8 finger_loss_counter = 0;
int8 finger_stable_counter = 0;

// Enhanced signal processing buffers
int32 ir_buffer[SIGNAL_BUFFER_SIZE];
int32 red_buffer[SIGNAL_BUFFER_SIZE];
int8 buffer_index = 0;
int1 buffer_full = 0;
int1 finger_stable = 0;

// Peak detection variables
int32 last_peak_time = 0;
int32 current_time = 0;
int16 peak_count = 0;
int32 rr_intervals[8]; // R-R interval buffer
int8 rr_index = 0;

// Calibration and filtering
int32 dc_red = 0, dc_ir = 0;
int32 ac_red = 0, ac_ir = 0;

// Function prototypes
void max30102_init();
int1 max30102_test_connection();
int1 max30102_read_and_process();
void max30102_write(int8 reg, int8 value);
int8 max30102_read(int8 reg);
void max30102_read_fifo(int32 *red, int32 *ir);
void max30102_reset_fifo();
int16 calculate_heart_rate();
int16 calculate_spo2();
int1 detect_finger();
void process_signal_quality();

// Enhanced initialization with comprehensive setup
void max30102_init() {
   // Software reset
   max30102_write(REG_MODE_CONFIG, 0x40);
   delay_ms(100);
   
   // Wait for reset to complete
   while (max30102_read(REG_MODE_CONFIG) & 0x40) {
      delay_ms(10);
   }
   
   // Configure FIFO
   max30102_write(REG_FIFO_CONFIG, 0x4F); // FIFO almost full = 15, rollover enabled, sample avg = 4
   
   // Configure mode (SpO2 mode)
   max30102_write(REG_MODE_CONFIG, 0x03);
   
   // Configure SpO2 (100Hz, 411µs, 18-bit resolution)
   max30102_write(REG_SPO2_CONFIG, 0x27);
   
   // Configure LED pulse amplitudes (start conservative)
   max30102_write(REG_LED1_PA, 0x1F); // Red LED
   max30102_write(REG_LED2_PA, 0x1F); // IR LED
   
   // Clear FIFO pointers
   max30102_reset_fifo();
   
   // Initialize buffers
   for (int8 i = 0; i < SIGNAL_BUFFER_SIZE; i++) {
      ir_buffer[i] = 0;
      red_buffer[i] = 0;
   }
   
   for (int8 i = 0; i < 8; i++) {
      rr_intervals[i] = 0;
   }
   
   buffer_index = 0;
   buffer_full = 0;
   finger_stable = 0;
   current_time = 0;
}

// Test I2C connection
int1 max30102_test_connection() {
   int8 part_id = max30102_read(REG_PART_ID);
   return (part_id == 0x15); // MAX30102 part ID
}

// Enhanced read and process function
int1 max30102_read_and_process() {
   int32 red, ir;
   
   // Test I2C communication
   i2c_start();
   i2c_status = !i2c_write(MAX30102_ADDRESS);
   i2c_stop();
   
   if (!i2c_status) {
      return 0; // Communication failed
   }
   
   // Read FIFO data
   max30102_read_fifo(&red, &ir);
   
   // Bounds checking
   if (red > 262143) red = 262143;
   if (ir > 262143) ir = 262143;
   
   red_value = (int16)(red >> 4); // Scale to 16-bit
   ir_value = (int16)(ir >> 4);
   
   current_time++;
   
   // Enhanced finger detection with multiple criteria
   if (!detect_finger()) {
      finger_loss_counter++;
      if (finger_loss_counter > 8) { // Confirm finger removal
         finger_detected = 0;
         finger_stable = 0;
         finger_stable_counter = 0;
         hr_value = 0;
         spo2_value = 0;
         hr_update_counter = 0;
         spo2_update_counter = 0;
         buffer_full = 0;
         buffer_index = 0;
         peak_count = 0;
         return 1;
      }
   } else {
      finger_loss_counter = 0;
      if (!finger_detected) {
         finger_detected = 1;
         finger_stable_counter = 0;
      }
   }
   
   if (finger_detected) {
      // Store samples in circular buffer
      ir_buffer[buffer_index] = ir_value;
      red_buffer[buffer_index] = red_value;
      buffer_index = (buffer_index + 1) % SIGNAL_BUFFER_SIZE;
      
      if (buffer_index == 0) {
         buffer_full = 1;
      }
      
      finger_stable_counter++;
      if (finger_stable_counter > 16 && buffer_full) {
         finger_stable = 1;
      }
      
      if (finger_stable) {
         process_signal_quality();
         
         hr_update_counter++;
         spo2_update_counter++;
         
         // Update heart rate every 2 seconds
         if (hr_update_counter >= 40) {
            hr_value = calculate_heart_rate();
            hr_update_counter = 0;
         }
         
         // Update SpO2 every 3 seconds  
         if (spo2_update_counter >= 60) {
            spo2_value = calculate_spo2();
            spo2_update_counter = 0;
         }
      }
   }
   
   return 1; // Success
}

// Advanced finger detection
int1 detect_finger() {
   // Multiple criteria for robust detection
   int1 signal_present = (red_value > 1000 && ir_value > 1000);
   int1 signal_not_saturated = (red_value < 60000 && ir_value < 60000);
   int1 signal_stable = 1;
   
   if (buffer_full) {
      // Check signal variance for stability
      int32 ir_sum = 0, red_sum = 0;
      for (int8 i = 0; i < 8; i++) {
         ir_sum += ir_buffer[i];
         red_sum += red_buffer[i];
      }
      int32 ir_avg = ir_sum >> 3;
      int32 red_avg = red_sum >> 3;
      
      int32 ir_variance = 0, red_variance = 0;
      for (int8 i = 0; i < 8; i++) {
         int32 diff_ir = ir_buffer[i] - ir_avg;
         int32 diff_red = red_buffer[i] - red_avg;
         if (diff_ir < 0) diff_ir = -diff_ir;
         if (diff_red < 0) diff_red = -diff_red;
         ir_variance += diff_ir;
         red_variance += diff_red;
      }
      
      // Signal should have some variance (heartbeat) but not too much (noise)
      signal_stable = (ir_variance > 50 && ir_variance < 5000 && 
                      red_variance > 50 && red_variance < 5000);
   }
   
   return (signal_present && signal_not_saturated && signal_stable);
}

// Enhanced heart rate calculation with peak detection
int16 calculate_heart_rate() {
   if (!buffer_full) return hr_value; // Keep previous value
   
   // Simple peak detection algorithm
   int8 peaks_found = 0;
   int32 peak_intervals[8];
   int8 last_peak_index = 0;
   
   // Find peaks in IR signal
   for (int8 i = 2; i < SIGNAL_BUFFER_SIZE - 2; i++) {
      if (ir_buffer[i] > ir_buffer[i-1] && ir_buffer[i] > ir_buffer[i+1] &&
          ir_buffer[i] > ir_buffer[i-2] && ir_buffer[i] > ir_buffer[i+2]) {
         
         // Check if peak is significant
         int32 peak_height = ir_buffer[i];
         int32 valley_left = ir_buffer[i-2] < ir_buffer[i-1] ? ir_buffer[i-2] : ir_buffer[i-1];
         int32 valley_right = ir_buffer[i+2] < ir_buffer[i+1] ? ir_buffer[i+2] : ir_buffer[i+1];
         int32 min_valley = valley_left < valley_right ? valley_left : valley_right;
         
         if ((peak_height - min_valley) > PEAK_DETECTION_THRESHOLD) {
            if (peaks_found > 0) {
               peak_intervals[peaks_found-1] = i - last_peak_index;
            }
            last_peak_index = i;
            peaks_found++;
            if (peaks_found >= 8) break;
         }
      }
   }
   
   if (peaks_found < 2) return hr_value; // Keep previous value
   
   // Calculate average interval
   int32 total_interval = 0;
   for (int8 i = 0; i < peaks_found - 1; i++) {
      total_interval += peak_intervals[i];
   }
   
   if (total_interval == 0) return hr_value;
   
   int32 avg_interval = total_interval / (peaks_found - 1);
   
   // Convert to BPM (sampling at ~50Hz effective rate)
   int16 calculated_hr = (int16)(3000 / avg_interval); // 60 * 50
   
   // Validate range
   if (calculated_hr < MIN_HEART_RATE || calculated_hr > MAX_HEART_RATE) {
      return hr_value; // Keep previous value if out of range
   }
   
   return calculated_hr;
}

// Enhanced SpO2 calculation
int16 calculate_spo2() {
   if (!buffer_full) return spo2_value;
   
   // Calculate DC and AC components
   int32 red_sum = 0, ir_sum = 0;
   int32 red_max = red_buffer[0], red_min = red_buffer[0];
   int32 ir_max = ir_buffer[0], ir_min = ir_buffer[0];
   
   for (int8 i = 0; i < SIGNAL_BUFFER_SIZE; i++) {
      red_sum += red_buffer[i];
      ir_sum += ir_buffer[i];
      
      if (red_buffer[i] > red_max) red_max = red_buffer[i];
      if (red_buffer[i] < red_min) red_min = red_buffer[i];
      if (ir_buffer[i] > ir_max) ir_max = ir_buffer[i];
      if (ir_buffer[i] < ir_min) ir_min = ir_buffer[i];
   }
   
   dc_red = red_sum >> 5; // Divide by 32
   dc_ir = ir_sum >> 5;
   ac_red = red_max - red_min;
   ac_ir = ir_max - ir_min;
   
   // Avoid division by zero
   if (dc_red == 0 || dc_ir == 0 || ac_ir == 0) {
      return spo2_value;
   }
   
   // Calculate R ratio
   int32 ratio_red = (ac_red * 100) / dc_red;
   int32 ratio_ir = (ac_ir * 100) / dc_ir;
   
   if (ratio_ir == 0) return spo2_value;
   
   int32 r_ratio = (ratio_red * 100) / ratio_ir;
   
   // Simplified SpO2 calculation (linear approximation)
   int16 calculated_spo2 = 110 - (r_ratio / 4);
   
   // Validate range
   if (calculated_spo2 < MIN_SPO2 || calculated_spo2 > MAX_SPO2) {
      return spo2_value; // Keep previous value
   }
   
   return calculated_spo2;
}

// Process signal quality and auto-adjust LED current
void process_signal_quality() {
   if (!buffer_full) return;
   
   // Check signal amplitude
   int32 ir_amplitude = 0;
   for (int8 i = 1; i < SIGNAL_BUFFER_SIZE; i++) {
      int32 diff = ir_buffer[i] - ir_buffer[i-1];
      if (diff < 0) diff = -diff;
      ir_amplitude += diff;
   }
   
   // Auto-adjust LED current based on signal quality
   static int8 led_adjust_counter = 0;
   led_adjust_counter++;
   
   if (led_adjust_counter > 50) { // Adjust every ~2.5 seconds
      int8 current_led = max30102_read(REG_LED2_PA);
      
      if (ir_amplitude < 1000 && current_led < 0x3F) {
         // Signal too weak, increase LED current
         max30102_write(REG_LED1_PA, current_led + 0x08);
         max30102_write(REG_LED2_PA, current_led + 0x08);
      } else if (ir_amplitude > 10000 && current_led > 0x10) {
         // Signal too strong, decrease LED current
         max30102_write(REG_LED1_PA, current_led - 0x08);
         max30102_write(REG_LED2_PA, current_led - 0x08);
      }
      
      led_adjust_counter = 0;
   }
}

// Reset FIFO pointers
void max30102_reset_fifo() {
   max30102_write(REG_FIFO_WR_PTR, 0x00);
   max30102_write(REG_OVF_COUNTER, 0x00);
   max30102_write(REG_FIFO_RD_PTR, 0x00);
}

void max30102_write(int8 reg, int8 value) {
   i2c_start();
   i2c_write(MAX30102_ADDRESS);
   i2c_write(reg);
   i2c_write(value);
   i2c_stop();
   delay_us(50); // Small delay for stability
}

int8 max30102_read(int8 reg) {
   int8 value;
   i2c_start();
   i2c_write(MAX30102_ADDRESS);
   i2c_write(reg);
   i2c_start();
   i2c_write(MAX30102_ADDRESS | 0x01);
   value = i2c_read(0);
   i2c_stop();
   delay_us(50);
   return value;
}

void max30102_read_fifo(int32 *red, int32 *ir) {
   int8 fifo_data[6];
   int8 i;
   
   i2c_start();
   i2c_write(MAX30102_ADDRESS);
   i2c_write(REG_FIFO_DATA);
   i2c_start();
   i2c_write(MAX30102_ADDRESS | 0x01);
   
   for (i = 0; i < 5; i++) {
      fifo_data[i] = i2c_read(1);
   }
   fifo_data[5] = i2c_read(0);
   i2c_stop();
   
   raw_byte = fifo_data[0];
   
   *red = ((int32)fifo_data[0] << 16) | ((int32)fifo_data[1] << 8) | fifo_data[2];
   *ir = ((int32)fifo_data[3] << 16) | ((int32)fifo_data[4] << 8) | fifo_data[5];
   
   *red &= 0x3FFFF; // 18-bit mask
   *ir &= 0x3FFFF;
}

#endif
