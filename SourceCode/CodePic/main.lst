CCS PCM C Compiler, Version 5.051, 43599               29-May-25 11:55

               Filename:   D:\nam3hk2\doan1\codedoan\main.lst

               ROM used:   6888 words (84%)
                           Largest free fragment is 1057
               RAM used:   84 (23%) at main() level
                           189 (51%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA 53,28
0005:  DATA 4F,19
0006:  DATA BA,12
0007:  DATA 6C,32
0008:  DATA 20,00
*
01A9:  BTFSC  03.1
01AA:  GOTO   1AE
01AB:  MOVLW  18
01AC:  MOVWF  04
01AD:  BSF    03.7
01AE:  CLRF   77
01AF:  CLRF   78
01B0:  CLRF   79
01B1:  CLRF   7A
01B2:  BSF    03.6
01B3:  CLRF   18
01B4:  CLRF   19
01B5:  CLRF   1A
01B6:  CLRF   1B
01B7:  MOVF   17,W
01B8:  IORWF  16,W
01B9:  IORWF  15,W
01BA:  IORWF  14,W
01BB:  BTFSC  03.2
01BC:  GOTO   1ED
01BD:  MOVLW  20
01BE:  MOVWF  1C
01BF:  BCF    03.0
01C0:  RLF    10,F
01C1:  RLF    11,F
01C2:  RLF    12,F
01C3:  RLF    13,F
01C4:  RLF    18,F
01C5:  RLF    19,F
01C6:  RLF    1A,F
01C7:  RLF    1B,F
01C8:  MOVF   17,W
01C9:  SUBWF  1B,W
01CA:  BTFSS  03.2
01CB:  GOTO   1D6
01CC:  MOVF   16,W
01CD:  SUBWF  1A,W
01CE:  BTFSS  03.2
01CF:  GOTO   1D6
01D0:  MOVF   15,W
01D1:  SUBWF  19,W
01D2:  BTFSS  03.2
01D3:  GOTO   1D6
01D4:  MOVF   14,W
01D5:  SUBWF  18,W
01D6:  BTFSS  03.0
01D7:  GOTO   1E7
01D8:  MOVF   14,W
01D9:  SUBWF  18,F
01DA:  MOVF   15,W
01DB:  BTFSS  03.0
01DC:  INCFSZ 15,W
01DD:  SUBWF  19,F
01DE:  MOVF   16,W
01DF:  BTFSS  03.0
01E0:  INCFSZ 16,W
01E1:  SUBWF  1A,F
01E2:  MOVF   17,W
01E3:  BTFSS  03.0
01E4:  INCFSZ 17,W
01E5:  SUBWF  1B,F
01E6:  BSF    03.0
01E7:  RLF    77,F
01E8:  RLF    78,F
01E9:  RLF    79,F
01EA:  RLF    7A,F
01EB:  DECFSZ 1C,F
01EC:  GOTO   1BF
01ED:  MOVF   18,W
01EE:  MOVWF  00
01EF:  INCF   04,F
01F0:  MOVF   19,W
01F1:  MOVWF  00
01F2:  INCF   04,F
01F3:  MOVF   1A,W
01F4:  MOVWF  00
01F5:  INCF   04,F
01F6:  MOVF   1B,W
01F7:  MOVWF  00
01F8:  BCF    03.6
01F9:  RETURN
*
0277:  BSF    03.5
0278:  MOVF   25,W
0279:  MOVWF  2C
027A:  MOVF   29,W
027B:  XORWF  2C,F
027C:  BTFSS  2C.7
027D:  GOTO   283
027E:  BCF    03.2
027F:  BCF    03.0
0280:  BTFSC  25.7
0281:  BSF    03.0
0282:  GOTO   2B6
0283:  MOVF   25,W
0284:  MOVWF  2C
0285:  MOVF   28,W
0286:  MOVWF  2D
0287:  MOVF   24,W
0288:  SUBWF  2D,F
0289:  BTFSC  03.2
028A:  GOTO   291
028B:  BTFSS  2C.7
028C:  GOTO   2B6
028D:  MOVF   03,W
028E:  XORLW  01
028F:  MOVWF  03
0290:  GOTO   2B6
0291:  MOVF   29,W
0292:  MOVWF  2D
0293:  MOVF   25,W
0294:  SUBWF  2D,F
0295:  BTFSC  03.2
0296:  GOTO   29D
0297:  BTFSS  2C.7
0298:  GOTO   2B6
0299:  MOVF   03,W
029A:  XORLW  01
029B:  MOVWF  03
029C:  GOTO   2B6
029D:  MOVF   2A,W
029E:  MOVWF  2D
029F:  MOVF   26,W
02A0:  SUBWF  2D,F
02A1:  BTFSC  03.2
02A2:  GOTO   2A9
02A3:  BTFSS  2C.7
02A4:  GOTO   2B6
02A5:  MOVF   03,W
02A6:  XORLW  01
02A7:  MOVWF  03
02A8:  GOTO   2B6
02A9:  MOVF   2B,W
02AA:  MOVWF  2D
02AB:  MOVF   27,W
02AC:  SUBWF  2D,F
02AD:  BTFSC  03.2
02AE:  GOTO   2B5
02AF:  BTFSS  2C.7
02B0:  GOTO   2B6
02B1:  MOVF   03,W
02B2:  XORLW  01
02B3:  MOVWF  03
02B4:  GOTO   2B6
02B5:  BCF    03.0
02B6:  BCF    03.5
02B7:  RETURN
02B8:  MOVLW  8E
02B9:  MOVWF  77
02BA:  BSF    03.5
02BB:  MOVF   21,W
02BC:  MOVWF  78
02BD:  MOVF   20,W
02BE:  MOVWF  79
02BF:  CLRF   7A
02C0:  MOVF   78,F
02C1:  BTFSS  03.2
02C2:  GOTO   2CD
02C3:  MOVF   79,W
02C4:  MOVWF  78
02C5:  CLRF   79
02C6:  MOVLW  08
02C7:  SUBWF  77,F
02C8:  MOVF   78,F
02C9:  BTFSS  03.2
02CA:  GOTO   2CD
02CB:  CLRF   77
02CC:  GOTO   2D5
02CD:  BCF    03.0
02CE:  BTFSC  78.7
02CF:  GOTO   2D4
02D0:  RLF    79,F
02D1:  RLF    78,F
02D2:  DECF   77,F
02D3:  GOTO   2CD
02D4:  BCF    78.7
02D5:  BCF    03.5
02D6:  RETURN
02D7:  BSF    03.5
02D8:  MOVF   20,W
02D9:  BTFSC  03.2
02DA:  GOTO   39D
02DB:  MOVWF  2C
02DC:  MOVF   24,W
02DD:  BTFSC  03.2
02DE:  GOTO   39D
02DF:  SUBWF  2C,F
02E0:  BTFSS  03.0
02E1:  GOTO   2E7
02E2:  MOVLW  7F
02E3:  ADDWF  2C,F
02E4:  BTFSC  03.0
02E5:  GOTO   39D
02E6:  GOTO   2ED
02E7:  MOVLW  81
02E8:  SUBWF  2C,F
02E9:  BTFSS  03.0
02EA:  GOTO   39D
02EB:  BTFSC  03.2
02EC:  GOTO   39D
02ED:  MOVF   2C,W
02EE:  MOVWF  77
02EF:  CLRF   78
02F0:  CLRF   79
02F1:  CLRF   7A
02F2:  CLRF   2B
02F3:  MOVF   21,W
02F4:  MOVWF  2A
02F5:  BSF    2A.7
02F6:  MOVF   22,W
02F7:  MOVWF  29
02F8:  MOVF   23,W
02F9:  MOVWF  28
02FA:  MOVLW  19
02FB:  MOVWF  2C
02FC:  MOVF   27,W
02FD:  SUBWF  28,F
02FE:  BTFSC  03.0
02FF:  GOTO   310
0300:  MOVLW  01
0301:  SUBWF  29,F
0302:  BTFSC  03.0
0303:  GOTO   310
0304:  SUBWF  2A,F
0305:  BTFSC  03.0
0306:  GOTO   310
0307:  SUBWF  2B,F
0308:  BTFSC  03.0
0309:  GOTO   310
030A:  INCF   2B,F
030B:  INCF   2A,F
030C:  INCF   29,F
030D:  MOVF   27,W
030E:  ADDWF  28,F
030F:  GOTO   342
0310:  MOVF   26,W
0311:  SUBWF  29,F
0312:  BTFSC  03.0
0313:  GOTO   32B
0314:  MOVLW  01
0315:  SUBWF  2A,F
0316:  BTFSC  03.0
0317:  GOTO   32B
0318:  SUBWF  2B,F
0319:  BTFSC  03.0
031A:  GOTO   32B
031B:  INCF   2B,F
031C:  INCF   2A,F
031D:  MOVF   26,W
031E:  ADDWF  29,F
031F:  MOVF   27,W
0320:  ADDWF  28,F
0321:  BTFSS  03.0
0322:  GOTO   342
0323:  INCF   29,F
0324:  BTFSS  03.2
0325:  GOTO   342
0326:  INCF   2A,F
0327:  BTFSS  03.2
0328:  GOTO   342
0329:  INCF   2B,F
032A:  GOTO   342
032B:  MOVF   25,W
032C:  IORLW  80
032D:  SUBWF  2A,F
032E:  BTFSC  03.0
032F:  GOTO   341
0330:  MOVLW  01
0331:  SUBWF  2B,F
0332:  BTFSC  03.0
0333:  GOTO   341
0334:  INCF   2B,F
0335:  MOVF   25,W
0336:  IORLW  80
0337:  ADDWF  2A,F
0338:  MOVF   26,W
0339:  ADDWF  29,F
033A:  BTFSS  03.0
033B:  GOTO   31F
033C:  INCF   2A,F
033D:  BTFSS  03.2
033E:  GOTO   31F
033F:  INCF   2B,F
0340:  GOTO   31F
0341:  BSF    7A.0
0342:  DECFSZ 2C,F
0343:  GOTO   345
0344:  GOTO   350
0345:  BCF    03.0
0346:  RLF    28,F
0347:  RLF    29,F
0348:  RLF    2A,F
0349:  RLF    2B,F
034A:  BCF    03.0
034B:  RLF    7A,F
034C:  RLF    79,F
034D:  RLF    78,F
034E:  RLF    2D,F
034F:  GOTO   2FC
0350:  BTFSS  2D.0
0351:  GOTO   358
0352:  BCF    03.0
0353:  RRF    78,F
0354:  RRF    79,F
0355:  RRF    7A,F
0356:  RRF    2D,F
0357:  GOTO   35B
0358:  DECF   77,F
0359:  BTFSC  03.2
035A:  GOTO   39D
035B:  BTFSC  2D.7
035C:  GOTO   384
035D:  BCF    03.0
035E:  RLF    28,F
035F:  RLF    29,F
0360:  RLF    2A,F
0361:  RLF    2B,F
0362:  MOVF   27,W
0363:  SUBWF  28,F
0364:  BTFSC  03.0
0365:  GOTO   370
0366:  MOVLW  01
0367:  SUBWF  29,F
0368:  BTFSC  03.0
0369:  GOTO   370
036A:  SUBWF  2A,F
036B:  BTFSC  03.0
036C:  GOTO   370
036D:  SUBWF  2B,F
036E:  BTFSS  03.0
036F:  GOTO   393
0370:  MOVF   26,W
0371:  SUBWF  29,F
0372:  BTFSC  03.0
0373:  GOTO   37B
0374:  MOVLW  01
0375:  SUBWF  2A,F
0376:  BTFSC  03.0
0377:  GOTO   37B
0378:  SUBWF  2B,F
0379:  BTFSS  03.0
037A:  GOTO   393
037B:  MOVF   25,W
037C:  IORLW  80
037D:  SUBWF  2A,F
037E:  BTFSC  03.0
037F:  GOTO   384
0380:  MOVLW  01
0381:  SUBWF  2B,F
0382:  BTFSS  03.0
0383:  GOTO   393
0384:  INCF   7A,F
0385:  BTFSS  03.2
0386:  GOTO   393
0387:  INCF   79,F
0388:  BTFSS  03.2
0389:  GOTO   393
038A:  INCF   78,F
038B:  BTFSS  03.2
038C:  GOTO   393
038D:  INCF   77,F
038E:  BTFSC  03.2
038F:  GOTO   39D
0390:  RRF    78,F
0391:  RRF    79,F
0392:  RRF    7A,F
0393:  MOVF   21,W
0394:  MOVWF  2C
0395:  MOVF   25,W
0396:  XORWF  2C,F
0397:  BTFSS  2C.7
0398:  GOTO   39B
0399:  BSF    78.7
039A:  GOTO   3A1
039B:  BCF    78.7
039C:  GOTO   3A1
039D:  CLRF   77
039E:  CLRF   78
039F:  CLRF   79
03A0:  CLRF   7A
03A1:  BCF    03.5
03A2:  RETURN
*
07EE:  MOVF   58,W
07EF:  MOVWF  04
07F0:  BCF    03.7
07F1:  BTFSC  59.0
07F2:  BSF    03.7
07F3:  BSF    03.6
07F4:  MOVF   10,W
07F5:  MOVWF  00
07F6:  INCF   04,F
07F7:  CLRF   00
07F8:  BCF    03.6
07F9:  INCF   58,F
07FA:  BTFSC  03.2
07FB:  INCF   59,F
07FC:  RETURN
*
0800:  CLRF   78
0801:  CLRF   79
0802:  CLRF   77
0803:  CLRF   7A
0804:  MOVF   72,W
0805:  BTFSS  03.2
0806:  GOTO   00A
0807:  MOVF   71,W
0808:  BTFSC  03.2
0809:  GOTO   024
080A:  MOVLW  10
080B:  MOVWF  73
080C:  BCF    03.0
080D:  RLF    6F,F
080E:  RLF    70,F
080F:  RLF    77,F
0810:  RLF    7A,F
0811:  MOVF   72,W
0812:  SUBWF  7A,W
0813:  BTFSS  03.2
0814:  GOTO   017
0815:  MOVF   71,W
0816:  SUBWF  77,W
0817:  BTFSS  03.0
0818:  GOTO   020
0819:  MOVF   71,W
081A:  SUBWF  77,F
081B:  BTFSS  03.0
081C:  DECF   7A,F
081D:  MOVF   72,W
081E:  SUBWF  7A,F
081F:  BSF    03.0
0820:  RLF    78,F
0821:  RLF    79,F
0822:  DECFSZ 73,F
0823:  GOTO   00C
0824:  RETURN
*
08D0:  MOVF   20,W
08D1:  BTFSC  03.2
08D2:  GOTO   140
08D3:  MOVWF  28
08D4:  MOVF   24,W
08D5:  BTFSC  03.2
08D6:  GOTO   140
08D7:  ADDWF  28,F
08D8:  BTFSC  03.0
08D9:  GOTO   0E1
08DA:  MOVLW  7F
08DB:  SUBWF  28,F
08DC:  BTFSS  03.0
08DD:  GOTO   140
08DE:  BTFSC  03.2
08DF:  GOTO   140
08E0:  GOTO   0E5
08E1:  MOVLW  81
08E2:  ADDWF  28,F
08E3:  BTFSC  03.0
08E4:  GOTO   140
08E5:  MOVF   28,W
08E6:  MOVWF  77
08E7:  CLRF   78
08E8:  CLRF   79
08E9:  CLRF   7A
08EA:  MOVF   21,W
08EB:  MOVWF  2C
08EC:  BSF    2C.7
08ED:  MOVF   22,W
08EE:  MOVWF  2B
08EF:  MOVF   23,W
08F0:  MOVWF  2A
08F1:  MOVLW  18
08F2:  MOVWF  28
08F3:  CLRF   29
08F4:  BTFSS  2A.0
08F5:  GOTO   10E
08F6:  MOVF   27,W
08F7:  ADDWF  7A,F
08F8:  BTFSS  03.0
08F9:  GOTO   100
08FA:  INCF   79,F
08FB:  BTFSS  03.2
08FC:  GOTO   100
08FD:  INCF   78,F
08FE:  BTFSC  03.2
08FF:  BSF    29.7
0900:  MOVF   26,W
0901:  ADDWF  79,F
0902:  BTFSS  03.0
0903:  GOTO   107
0904:  INCF   78,F
0905:  BTFSC  03.2
0906:  BSF    29.7
0907:  MOVF   25,W
0908:  MOVWF  22
0909:  BSF    22.7
090A:  MOVF   22,W
090B:  ADDWF  78,F
090C:  BTFSC  03.0
090D:  BSF    29.7
090E:  RLF    29,F
090F:  RRF    78,F
0910:  RRF    79,F
0911:  RRF    7A,F
0912:  RRF    2C,F
0913:  RRF    2B,F
0914:  RRF    2A,F
0915:  BCF    03.0
0916:  DECFSZ 28,F
0917:  GOTO   0F3
0918:  MOVLW  01
0919:  ADDWF  77,F
091A:  BTFSC  03.0
091B:  GOTO   140
091C:  BTFSC  78.7
091D:  GOTO   125
091E:  RLF    2C,F
091F:  RLF    7A,F
0920:  RLF    79,F
0921:  RLF    78,F
0922:  DECF   77,F
0923:  BTFSC  03.2
0924:  GOTO   140
0925:  BTFSS  2C.7
0926:  GOTO   136
0927:  INCF   7A,F
0928:  BTFSS  03.2
0929:  GOTO   136
092A:  INCF   79,F
092B:  BTFSS  03.2
092C:  GOTO   136
092D:  INCF   78,F
092E:  BTFSS  03.2
092F:  GOTO   136
0930:  RRF    78,F
0931:  RRF    79,F
0932:  RRF    7A,F
0933:  INCF   77,F
0934:  BTFSC  03.2
0935:  GOTO   140
0936:  MOVF   21,W
0937:  MOVWF  29
0938:  MOVF   25,W
0939:  XORWF  29,F
093A:  BTFSS  29.7
093B:  GOTO   13E
093C:  BSF    78.7
093D:  GOTO   144
093E:  BCF    78.7
093F:  GOTO   144
0940:  CLRF   77
0941:  CLRF   78
0942:  CLRF   79
0943:  CLRF   7A
*
0AA4:  MOVLW  80
0AA5:  BTFSC  03.1
0AA6:  XORWF  72,F
0AA7:  BSF    03.5
0AA8:  CLRF   22
0AA9:  CLRF   23
0AAA:  BCF    03.5
0AAB:  MOVF   6E,W
0AAC:  BSF    03.5
0AAD:  MOVWF  21
0AAE:  MOVF   72,W
0AAF:  XORWF  21,F
0AB0:  BCF    03.5
0AB1:  MOVF   6D,W
0AB2:  BTFSC  03.2
0AB3:  GOTO   3A6
0AB4:  BSF    03.5
0AB5:  MOVWF  20
0AB6:  MOVWF  77
0AB7:  MOVF   71,W
0AB8:  BTFSC  03.2
0AB9:  GOTO   3B0
0ABA:  SUBWF  20,F
0ABB:  BTFSC  03.2
0ABC:  GOTO   346
0ABD:  BTFSS  03.0
0ABE:  GOTO   2FE
0ABF:  MOVF   72,W
0AC0:  MOVWF  26
0AC1:  BSF    26.7
0AC2:  MOVF   73,W
0AC3:  MOVWF  25
0AC4:  MOVF   74,W
0AC5:  MOVWF  24
0AC6:  CLRF   23
0AC7:  BCF    03.0
0AC8:  RRF    26,F
0AC9:  RRF    25,F
0ACA:  RRF    24,F
0ACB:  RRF    23,F
0ACC:  DECFSZ 20,F
0ACD:  GOTO   2C6
0ACE:  BTFSS  21.7
0ACF:  GOTO   2D3
0AD0:  BSF    22.0
0AD1:  GOTO   3C8
0AD2:  BCF    22.0
0AD3:  BCF    20.0
0AD4:  BSF    22.4
0AD5:  MOVLW  70
0AD6:  MOVWF  04
0AD7:  BCF    03.7
0AD8:  GOTO   3DD
0AD9:  BCF    22.4
0ADA:  BTFSC  21.7
0ADB:  GOTO   2E6
0ADC:  BTFSS  20.0
0ADD:  GOTO   2F1
0ADE:  RRF    26,F
0ADF:  RRF    25,F
0AE0:  RRF    24,F
0AE1:  RRF    23,F
0AE2:  INCF   77,F
0AE3:  BTFSC  03.2
0AE4:  GOTO   3C3
0AE5:  GOTO   2F1
0AE6:  BTFSC  26.7
0AE7:  GOTO   2F4
0AE8:  BCF    03.0
0AE9:  RLF    23,F
0AEA:  RLF    24,F
0AEB:  RLF    25,F
0AEC:  RLF    26,F
0AED:  DECF   77,F
0AEE:  BTFSC  03.2
0AEF:  GOTO   3C3
0AF0:  GOTO   2E6
0AF1:  BSF    22.6
0AF2:  GOTO   368
0AF3:  BCF    22.6
0AF4:  BCF    03.5
0AF5:  MOVF   6E,W
0AF6:  BSF    03.5
0AF7:  MOVWF  21
0AF8:  BTFSS  21.7
0AF9:  GOTO   2FC
0AFA:  BSF    26.7
0AFB:  GOTO   3BC
0AFC:  BCF    26.7
0AFD:  GOTO   3BC
0AFE:  MOVF   71,W
0AFF:  MOVWF  20
0B00:  MOVWF  77
0B01:  BCF    03.5
0B02:  MOVF   6D,W
0B03:  BSF    03.5
0B04:  SUBWF  20,F
0B05:  BCF    03.5
0B06:  MOVF   6E,W
0B07:  BSF    03.5
0B08:  MOVWF  26
0B09:  BSF    26.7
0B0A:  BCF    03.5
0B0B:  MOVF   6F,W
0B0C:  BSF    03.5
0B0D:  MOVWF  25
0B0E:  MOVF   70,W
0B0F:  MOVWF  24
0B10:  CLRF   23
0B11:  BCF    03.0
0B12:  RRF    26,F
0B13:  RRF    25,F
0B14:  RRF    24,F
0B15:  RRF    23,F
0B16:  DECFSZ 20,F
0B17:  GOTO   310
0B18:  BTFSS  21.7
0B19:  GOTO   31D
0B1A:  BSF    22.1
0B1B:  GOTO   3C8
0B1C:  BCF    22.1
0B1D:  BCF    20.0
0B1E:  BSF    22.5
0B1F:  MOVLW  74
0B20:  MOVWF  04
0B21:  BCF    03.7
0B22:  GOTO   3DD
0B23:  BCF    22.5
0B24:  BTFSC  21.7
0B25:  GOTO   330
0B26:  BTFSS  20.0
0B27:  GOTO   33B
0B28:  RRF    26,F
0B29:  RRF    25,F
0B2A:  RRF    24,F
0B2B:  RRF    23,F
0B2C:  INCF   77,F
0B2D:  BTFSC  03.2
0B2E:  GOTO   3C3
0B2F:  GOTO   33B
0B30:  BTFSC  26.7
0B31:  GOTO   33E
0B32:  BCF    03.0
0B33:  RLF    23,F
0B34:  RLF    24,F
0B35:  RLF    25,F
0B36:  RLF    26,F
0B37:  DECF   77,F
0B38:  BTFSC  03.2
0B39:  GOTO   3C3
0B3A:  GOTO   330
0B3B:  BSF    22.7
0B3C:  GOTO   368
0B3D:  BCF    22.7
0B3E:  MOVF   72,W
0B3F:  MOVWF  21
0B40:  BTFSS  21.7
0B41:  GOTO   344
0B42:  BSF    26.7
0B43:  GOTO   3BC
0B44:  BCF    26.7
0B45:  GOTO   3BC
0B46:  MOVF   72,W
0B47:  MOVWF  26
0B48:  BSF    26.7
0B49:  MOVF   73,W
0B4A:  MOVWF  25
0B4B:  MOVF   74,W
0B4C:  MOVWF  24
0B4D:  BTFSS  21.7
0B4E:  GOTO   353
0B4F:  BCF    26.7
0B50:  BSF    22.2
0B51:  GOTO   3C8
0B52:  BCF    22.2
0B53:  CLRF   23
0B54:  BCF    20.0
0B55:  MOVLW  70
0B56:  MOVWF  04
0B57:  BCF    03.7
0B58:  GOTO   3DD
0B59:  BTFSC  21.7
0B5A:  GOTO   37E
0B5B:  BCF    03.5
0B5C:  MOVF   6E,W
0B5D:  BSF    03.5
0B5E:  MOVWF  21
0B5F:  BTFSS  20.0
0B60:  GOTO   368
0B61:  RRF    26,F
0B62:  RRF    25,F
0B63:  RRF    24,F
0B64:  RRF    23,F
0B65:  INCF   77,F
0B66:  BTFSC  03.2
0B67:  GOTO   3C3
0B68:  BTFSS  23.7
0B69:  GOTO   379
0B6A:  INCF   24,F
0B6B:  BTFSS  03.2
0B6C:  GOTO   379
0B6D:  INCF   25,F
0B6E:  BTFSS  03.2
0B6F:  GOTO   379
0B70:  INCF   26,F
0B71:  BTFSS  03.2
0B72:  GOTO   379
0B73:  RRF    26,F
0B74:  RRF    25,F
0B75:  RRF    24,F
0B76:  INCF   77,F
0B77:  BTFSC  03.2
0B78:  GOTO   3C3
0B79:  BTFSC  22.6
0B7A:  GOTO   2F3
0B7B:  BTFSC  22.7
0B7C:  GOTO   33D
0B7D:  GOTO   39F
0B7E:  MOVLW  80
0B7F:  XORWF  26,F
0B80:  BTFSS  26.7
0B81:  GOTO   386
0B82:  GOTO   3C8
0B83:  MOVF   72,W
0B84:  MOVWF  21
0B85:  GOTO   395
0B86:  BCF    03.5
0B87:  MOVF   6E,W
0B88:  BSF    03.5
0B89:  MOVWF  21
0B8A:  MOVF   26,F
0B8B:  BTFSS  03.2
0B8C:  GOTO   395
0B8D:  MOVF   25,F
0B8E:  BTFSS  03.2
0B8F:  GOTO   395
0B90:  MOVF   24,F
0B91:  BTFSS  03.2
0B92:  GOTO   395
0B93:  CLRF   77
0B94:  GOTO   3BC
0B95:  BTFSC  26.7
0B96:  GOTO   39F
0B97:  BCF    03.0
0B98:  RLF    23,F
0B99:  RLF    24,F
0B9A:  RLF    25,F
0B9B:  RLF    26,F
0B9C:  DECFSZ 77,F
0B9D:  GOTO   395
0B9E:  GOTO   3C3
0B9F:  BTFSS  21.7
0BA0:  GOTO   3A3
0BA1:  BSF    26.7
0BA2:  GOTO   3BC
0BA3:  BCF    26.7
0BA4:  GOTO   3BC
0BA5:  BCF    03.5
0BA6:  MOVF   71,W
0BA7:  MOVWF  77
0BA8:  MOVF   72,W
0BA9:  BSF    03.5
0BAA:  MOVWF  26
0BAB:  MOVF   73,W
0BAC:  MOVWF  25
0BAD:  MOVF   74,W
0BAE:  MOVWF  24
0BAF:  GOTO   3BC
0BB0:  BCF    03.5
0BB1:  MOVF   6D,W
0BB2:  MOVWF  77
0BB3:  MOVF   6E,W
0BB4:  BSF    03.5
0BB5:  MOVWF  26
0BB6:  BCF    03.5
0BB7:  MOVF   6F,W
0BB8:  BSF    03.5
0BB9:  MOVWF  25
0BBA:  MOVF   70,W
0BBB:  MOVWF  24
0BBC:  MOVF   26,W
0BBD:  MOVWF  78
0BBE:  MOVF   25,W
0BBF:  MOVWF  79
0BC0:  MOVF   24,W
0BC1:  MOVWF  7A
0BC2:  GOTO   3FB
0BC3:  CLRF   77
0BC4:  CLRF   78
0BC5:  CLRF   79
0BC6:  CLRF   7A
0BC7:  GOTO   3FB
0BC8:  CLRF   23
0BC9:  COMF   24,F
0BCA:  COMF   25,F
0BCB:  COMF   26,F
0BCC:  COMF   23,F
0BCD:  INCF   23,F
0BCE:  BTFSS  03.2
0BCF:  GOTO   3D6
0BD0:  INCF   24,F
0BD1:  BTFSS  03.2
0BD2:  GOTO   3D6
0BD3:  INCF   25,F
0BD4:  BTFSC  03.2
0BD5:  INCF   26,F
0BD6:  BTFSC  22.0
0BD7:  GOTO   2D2
0BD8:  BTFSC  22.1
0BD9:  GOTO   31C
0BDA:  BTFSC  22.2
0BDB:  GOTO   352
0BDC:  GOTO   383
0BDD:  MOVF   00,W
0BDE:  ADDWF  24,F
0BDF:  BTFSS  03.0
0BE0:  GOTO   3E7
0BE1:  INCF   25,F
0BE2:  BTFSS  03.2
0BE3:  GOTO   3E7
0BE4:  INCF   26,F
0BE5:  BTFSC  03.2
0BE6:  BSF    20.0
0BE7:  DECF   04,F
0BE8:  MOVF   00,W
0BE9:  ADDWF  25,F
0BEA:  BTFSS  03.0
0BEB:  GOTO   3EF
0BEC:  INCF   26,F
0BED:  BTFSC  03.2
0BEE:  BSF    20.0
0BEF:  DECF   04,F
0BF0:  MOVF   00,W
0BF1:  BTFSS  00.7
0BF2:  XORLW  80
0BF3:  ADDWF  26,F
0BF4:  BTFSC  03.0
0BF5:  BSF    20.0
0BF6:  BTFSC  22.4
0BF7:  GOTO   2D9
0BF8:  BTFSC  22.5
0BF9:  GOTO   323
0BFA:  GOTO   359
0BFB:  BCF    03.5
0BFC:  RETURN
0BFD:  MOVF   6D,W
0BFE:  SUBLW  B6
0BFF:  MOVWF  6D
0C00:  CLRF   7A
0C01:  MOVF   6E,W
0C02:  MOVWF  71
0C03:  BSF    6E.7
0C04:  BCF    03.0
0C05:  RRF    6E,F
0C06:  RRF    6F,F
0C07:  RRF    70,F
0C08:  RRF    7A,F
0C09:  RRF    79,F
0C0A:  RRF    78,F
0C0B:  RRF    77,F
0C0C:  DECFSZ 6D,F
0C0D:  GOTO   404
0C0E:  BTFSS  71.7
0C0F:  GOTO   41B
0C10:  COMF   77,F
0C11:  COMF   78,F
0C12:  COMF   79,F
0C13:  COMF   7A,F
0C14:  INCF   77,F
0C15:  BTFSC  03.2
0C16:  INCF   78,F
0C17:  BTFSC  03.2
0C18:  INCF   79,F
0C19:  BTFSC  03.2
0C1A:  INCF   7A,F
0C1B:  RETURN
0C1C:  BSF    03.5
0C1D:  MOVF   67,W
0C1E:  CLRF   78
0C1F:  SUBWF  66,W
0C20:  BTFSC  03.0
0C21:  GOTO   425
0C22:  MOVF   66,W
0C23:  MOVWF  77
0C24:  GOTO   431
0C25:  CLRF   77
0C26:  MOVLW  08
0C27:  MOVWF  68
0C28:  RLF    66,F
0C29:  RLF    77,F
0C2A:  MOVF   67,W
0C2B:  SUBWF  77,W
0C2C:  BTFSC  03.0
0C2D:  MOVWF  77
0C2E:  RLF    78,F
0C2F:  DECFSZ 68,F
0C30:  GOTO   428
0C31:  BCF    03.5
0C32:  RETURN
0C33:  MOVF   78,W
0C34:  BSF    03.5
0C35:  MOVF   64,W
0C36:  MOVWF  66
0C37:  MOVLW  64
0C38:  MOVWF  67
0C39:  BCF    03.5
0C3A:  CALL   41C
0C3B:  MOVF   77,W
0C3C:  BSF    03.5
0C3D:  MOVWF  64
0C3E:  MOVF   78,W
0C3F:  MOVLW  30
0C40:  BTFSS  03.2
0C41:  GOTO   449
0C42:  BTFSS  65.1
0C43:  GOTO   456
0C44:  BTFSC  65.3
0C45:  GOTO   456
0C46:  BTFSC  65.4
0C47:  MOVLW  20
0C48:  GOTO   44C
0C49:  BCF    65.3
0C4A:  BCF    65.4
0C4B:  BSF    65.0
0C4C:  ADDWF  78,F
0C4D:  MOVF   78,W
0C4E:  BCF    03.5
0C4F:  BSF    03.6
0C50:  MOVWF  10
0C51:  BCF    0A.3
0C52:  BCF    03.6
0C53:  CALL   7EE
0C54:  BSF    0A.3
0C55:  BSF    03.5
0C56:  MOVF   64,W
0C57:  MOVWF  66
0C58:  MOVLW  0A
0C59:  MOVWF  67
0C5A:  BCF    03.5
0C5B:  CALL   41C
0C5C:  MOVF   77,W
0C5D:  BSF    03.5
0C5E:  MOVWF  64
0C5F:  MOVF   78,W
0C60:  MOVLW  30
0C61:  BTFSS  03.2
0C62:  GOTO   469
0C63:  BTFSC  65.3
0C64:  GOTO   473
0C65:  BTFSS  65.0
0C66:  GOTO   473
0C67:  BTFSC  65.4
0C68:  MOVLW  20
0C69:  ADDWF  78,F
0C6A:  MOVF   78,W
0C6B:  BCF    03.5
0C6C:  BSF    03.6
0C6D:  MOVWF  10
0C6E:  BCF    0A.3
0C6F:  BCF    03.6
0C70:  CALL   7EE
0C71:  BSF    0A.3
0C72:  BSF    03.5
0C73:  MOVLW  30
0C74:  ADDWF  64,F
0C75:  MOVF   64,W
0C76:  BCF    03.5
0C77:  BSF    03.6
0C78:  MOVWF  10
0C79:  BCF    0A.3
0C7A:  BCF    03.6
0C7B:  CALL   7EE
0C7C:  BSF    0A.3
0C7D:  RETURN
0C7E:  MOVF   04,W
0C7F:  BSF    03.5
0C80:  MOVWF  68
0C81:  BTFSS  67.7
0C82:  GOTO   490
0C83:  DECF   68,F
0C84:  BSF    68.5
0C85:  COMF   64,F
0C86:  COMF   65,F
0C87:  COMF   66,F
0C88:  COMF   67,F
0C89:  INCF   64,F
0C8A:  BTFSC  03.2
0C8B:  INCF   65,F
0C8C:  BTFSC  03.2
0C8D:  INCF   66,F
0C8E:  BTFSC  03.2
0C8F:  INCF   67,F
0C90:  MOVLW  3B
0C91:  MOVWF  6F
0C92:  MOVLW  9A
0C93:  MOVWF  6E
0C94:  MOVLW  CA
0C95:  MOVWF  6D
0C96:  CLRF   6C
0C97:  MOVLW  0A
0C98:  MOVWF  6A
0C99:  BSF    03.1
0C9A:  MOVLW  E4
0C9B:  MOVWF  04
0C9C:  BCF    03.7
0C9D:  MOVF   67,W
0C9E:  BCF    03.5
0C9F:  BSF    03.6
0CA0:  MOVWF  13
0CA1:  BSF    03.5
0CA2:  BCF    03.6
0CA3:  MOVF   66,W
0CA4:  BCF    03.5
0CA5:  BSF    03.6
0CA6:  MOVWF  12
0CA7:  BSF    03.5
0CA8:  BCF    03.6
0CA9:  MOVF   65,W
0CAA:  BCF    03.5
0CAB:  BSF    03.6
0CAC:  MOVWF  11
0CAD:  BSF    03.5
0CAE:  BCF    03.6
0CAF:  MOVF   64,W
0CB0:  BCF    03.5
0CB1:  BSF    03.6
0CB2:  MOVWF  10
0CB3:  BSF    03.5
0CB4:  BCF    03.6
0CB5:  MOVF   6F,W
0CB6:  BCF    03.5
0CB7:  BSF    03.6
0CB8:  MOVWF  17
0CB9:  BSF    03.5
0CBA:  BCF    03.6
0CBB:  MOVF   6E,W
0CBC:  BCF    03.5
0CBD:  BSF    03.6
0CBE:  MOVWF  16
0CBF:  BSF    03.5
0CC0:  BCF    03.6
0CC1:  MOVF   6D,W
0CC2:  BCF    03.5
0CC3:  BSF    03.6
0CC4:  MOVWF  15
0CC5:  BSF    03.5
0CC6:  BCF    03.6
0CC7:  MOVF   6C,W
0CC8:  BCF    03.5
0CC9:  BSF    03.6
0CCA:  MOVWF  14
0CCB:  BCF    0A.3
0CCC:  BCF    03.6
0CCD:  CALL   1A9
0CCE:  BSF    0A.3
0CCF:  MOVF   78,W
0CD0:  MOVF   77,F
0CD1:  BTFSS  03.2
0CD2:  GOTO   4EA
0CD3:  BSF    03.5
0CD4:  MOVF   6A,W
0CD5:  XORLW  01
0CD6:  BTFSS  03.2
0CD7:  GOTO   4DA
0CD8:  BCF    03.5
0CD9:  GOTO   4EA
0CDA:  MOVF   68,W
0CDB:  BTFSC  03.2
0CDC:  GOTO   4ED
0CDD:  ANDLW  0F
0CDE:  SUBWF  6A,W
0CDF:  BTFSC  03.2
0CE0:  GOTO   4E3
0CE1:  BTFSC  03.0
0CE2:  GOTO   51B
0CE3:  BTFSC  68.7
0CE4:  GOTO   51B
0CE5:  BTFSC  68.6
0CE6:  GOTO   4ED
0CE7:  MOVLW  20
0CE8:  GOTO   511
0CE9:  BCF    03.5
0CEA:  MOVLW  20
0CEB:  BSF    03.5
0CEC:  ANDWF  68,F
0CED:  BTFSS  68.5
0CEE:  GOTO   4FE
0CEF:  BCF    68.5
0CF0:  MOVF   77,W
0CF1:  MOVWF  68
0CF2:  MOVLW  2D
0CF3:  BCF    03.5
0CF4:  BSF    03.6
0CF5:  MOVWF  10
0CF6:  BCF    0A.3
0CF7:  BCF    03.6
0CF8:  CALL   7EE
0CF9:  BSF    0A.3
0CFA:  BSF    03.5
0CFB:  MOVF   68,W
0CFC:  MOVWF  77
0CFD:  CLRF   68
0CFE:  MOVLW  30
0CFF:  BTFSS  68.5
0D00:  GOTO   511
0D01:  BCF    68.5
0D02:  MOVF   77,W
0D03:  MOVWF  68
0D04:  MOVLW  2D
0D05:  BCF    03.5
0D06:  BSF    03.6
0D07:  MOVWF  10
0D08:  BCF    0A.3
0D09:  BCF    03.6
0D0A:  CALL   7EE
0D0B:  BSF    0A.3
0D0C:  BSF    03.5
0D0D:  MOVF   68,W
0D0E:  MOVWF  77
0D0F:  CLRF   68
0D10:  MOVLW  30
0D11:  ADDWF  77,F
0D12:  MOVF   77,W
0D13:  BCF    03.5
0D14:  BSF    03.6
0D15:  MOVWF  10
0D16:  BCF    0A.3
0D17:  BCF    03.6
0D18:  CALL   7EE
0D19:  BSF    0A.3
0D1A:  BSF    03.5
0D1B:  BCF    03.1
0D1C:  MOVF   6F,W
0D1D:  BCF    03.5
0D1E:  BSF    03.6
0D1F:  MOVWF  13
0D20:  BSF    03.5
0D21:  BCF    03.6
0D22:  MOVF   6E,W
0D23:  BCF    03.5
0D24:  BSF    03.6
0D25:  MOVWF  12
0D26:  BSF    03.5
0D27:  BCF    03.6
0D28:  MOVF   6D,W
0D29:  BCF    03.5
0D2A:  BSF    03.6
0D2B:  MOVWF  11
0D2C:  BSF    03.5
0D2D:  BCF    03.6
0D2E:  MOVF   6C,W
0D2F:  BCF    03.5
0D30:  BSF    03.6
0D31:  MOVWF  10
0D32:  CLRF   17
0D33:  CLRF   16
0D34:  CLRF   15
0D35:  MOVLW  0A
0D36:  MOVWF  14
0D37:  BCF    0A.3
0D38:  BCF    03.6
0D39:  CALL   1A9
0D3A:  BSF    0A.3
0D3B:  MOVF   7A,W
0D3C:  BSF    03.5
0D3D:  MOVWF  6F
0D3E:  MOVF   79,W
0D3F:  MOVWF  6E
0D40:  MOVF   78,W
0D41:  MOVWF  6D
0D42:  MOVF   77,W
0D43:  MOVWF  6C
0D44:  DECFSZ 6A,F
0D45:  GOTO   499
0D46:  BCF    03.5
0D47:  RETURN
*
0E6A:  BCF    03.5
0E6B:  MOVF   0B,W
0E6C:  BSF    03.5
0E6D:  MOVWF  65
0E6E:  BCF    03.5
0E6F:  BCF    0B.7
0E70:  BSF    03.5
0E71:  BSF    03.6
0E72:  BSF    0C.7
0E73:  BSF    0C.0
0E74:  NOP
0E75:  NOP
0E76:  BCF    03.6
0E77:  BTFSS  65.7
0E78:  GOTO   67C
0E79:  BCF    03.5
0E7A:  BSF    0B.7
0E7B:  BSF    03.5
0E7C:  BTFSC  03.0
0E7D:  GOTO   6B9
0E7E:  BCF    03.5
0E7F:  BSF    03.6
0E80:  MOVF   0C,W
0E81:  ANDLW  7F
0E82:  BSF    03.5
0E83:  BCF    03.6
0E84:  MOVWF  65
0E85:  BCF    03.5
0E86:  BSF    03.6
0E87:  MOVF   0D,W
0E88:  BSF    03.5
0E89:  BCF    03.6
0E8A:  MOVWF  66
0E8B:  BCF    03.5
0E8C:  BSF    03.6
0E8D:  MOVF   0F,W
0E8E:  BSF    03.5
0E8F:  BCF    03.6
0E90:  MOVWF  67
0E91:  MOVF   65,W
0E92:  BCF    03.5
0E93:  BSF    03.6
0E94:  MOVWF  10
0E95:  BCF    0A.3
0E96:  BCF    03.6
0E97:  CALL   7EE
0E98:  BSF    0A.3
0E99:  BSF    03.5
0E9A:  MOVF   66,W
0E9B:  BCF    03.5
0E9C:  BSF    03.6
0E9D:  MOVWF  0D
0E9E:  BSF    03.5
0E9F:  BCF    03.6
0EA0:  MOVF   67,W
0EA1:  BCF    03.5
0EA2:  BSF    03.6
0EA3:  MOVWF  0F
0EA4:  BCF    03.6
0EA5:  MOVF   0B,W
0EA6:  BSF    03.5
0EA7:  MOVWF  68
0EA8:  BCF    03.5
0EA9:  BCF    0B.7
0EAA:  BSF    03.5
0EAB:  BSF    03.6
0EAC:  BSF    0C.7
0EAD:  BSF    0C.0
0EAE:  NOP
0EAF:  NOP
0EB0:  BCF    03.6
0EB1:  BTFSS  68.7
0EB2:  GOTO   6B6
0EB3:  BCF    03.5
0EB4:  BSF    0B.7
0EB5:  BSF    03.5
0EB6:  DECFSZ 64,F
0EB7:  GOTO   6B9
0EB8:  GOTO   6E8
0EB9:  BCF    03.5
0EBA:  BSF    03.6
0EBB:  RLF    0C,W
0EBC:  RLF    0E,W
0EBD:  ANDLW  7F
0EBE:  BSF    03.5
0EBF:  BCF    03.6
0EC0:  MOVWF  65
0EC1:  BCF    03.5
0EC2:  BSF    03.6
0EC3:  MOVF   0D,W
0EC4:  BSF    03.5
0EC5:  BCF    03.6
0EC6:  MOVWF  66
0EC7:  BCF    03.5
0EC8:  BSF    03.6
0EC9:  MOVF   0F,W
0ECA:  BSF    03.5
0ECB:  BCF    03.6
0ECC:  MOVWF  67
0ECD:  MOVF   65,W
0ECE:  BCF    03.5
0ECF:  BSF    03.6
0ED0:  MOVWF  10
0ED1:  BCF    0A.3
0ED2:  BCF    03.6
0ED3:  CALL   7EE
0ED4:  BSF    0A.3
0ED5:  BSF    03.5
0ED6:  MOVF   66,W
0ED7:  BCF    03.5
0ED8:  BSF    03.6
0ED9:  MOVWF  0D
0EDA:  BSF    03.5
0EDB:  BCF    03.6
0EDC:  MOVF   67,W
0EDD:  BCF    03.5
0EDE:  BSF    03.6
0EDF:  MOVWF  0F
0EE0:  INCF   0D,F
0EE1:  BTFSC  03.2
0EE2:  INCF   0F,F
0EE3:  BCF    03.0
0EE4:  BSF    03.5
0EE5:  BCF    03.6
0EE6:  DECFSZ 64,F
0EE7:  GOTO   66A
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=8000000) 
*
002E:  MOVLW  AC
002F:  MOVWF  04
0030:  BCF    03.7
0031:  MOVF   00,W
0032:  BTFSC  03.2
0033:  GOTO   041
0034:  MOVLW  02
0035:  MOVWF  78
0036:  CLRF   77
0037:  DECFSZ 77,F
0038:  GOTO   037
0039:  DECFSZ 78,F
003A:  GOTO   036
003B:  MOVLW  97
003C:  MOVWF  77
003D:  DECFSZ 77,F
003E:  GOTO   03D
003F:  DECFSZ 00,F
0040:  GOTO   034
0041:  RETURN
.................... #use fast_io(D) 
.................... #use fast_io(C) 
.................... #use fast_io(B) 
.................... #use standard_io(A) 
....................  
.................... #include "lcd.h" 
.................... #ifndef __LCD_H 
.................... #define __LCD_H 
....................  
.................... #define LCD_RS PIN_D2 
.................... #define LCD_EN PIN_D3 
.................... #define LCD_D4 PIN_D4 
.................... #define LCD_D5 PIN_D5 
.................... #define LCD_D6 PIN_D6 
.................... #define LCD_D7 PIN_D7 
....................  
.................... #define LINE_1 0x80 
.................... #define LINE_2 0xC0 
.................... #define LINE_3 0x90 
.................... #define LINE_4 0xD0 
.................... #define CLEAR_SCR 0x01 
....................  
.................... #separate void LCD_Init(void); 
.................... #separate void LCD_SetPosition(unsigned int pos); 
.................... #separate void LCD_PutChar(unsigned int c); 
.................... #separate void LCD_PutCmd(unsigned int cmd); 
.................... #separate void LCD_PulseEnable(void); 
.................... #separate void LCD_SetData(unsigned int data); 
....................  
.................... #separate void LCD_Init(void) { 
....................    LCD_SetData(0x00); 
*
0060:  BSF    03.5
0061:  CLRF   2D
0062:  BCF    03.5
0063:  CALL   009
....................    delay_ms(200); 
0064:  MOVLW  C8
0065:  BSF    03.5
0066:  MOVWF  2C
0067:  BCF    03.5
0068:  CALL   02E
....................    output_low(LCD_RS); 
0069:  BCF    08.2
....................    LCD_SetData(0x03); 
006A:  MOVLW  03
006B:  BSF    03.5
006C:  MOVWF  2D
006D:  BCF    03.5
006E:  CALL   009
....................    LCD_PulseEnable(); 
006F:  CALL   042
....................    LCD_PulseEnable(); 
0070:  CALL   042
....................    LCD_PulseEnable(); 
0071:  CALL   042
....................    LCD_SetData(0x02); 
0072:  MOVLW  02
0073:  BSF    03.5
0074:  MOVWF  2D
0075:  BCF    03.5
0076:  CALL   009
....................    LCD_PulseEnable(); 
0077:  CALL   042
....................    LCD_PutCmd(0x2C); // 4-bit, 2-line, 5x8 dots 
0078:  MOVLW  2C
0079:  BSF    03.5
007A:  MOVWF  2B
007B:  BCF    03.5
007C:  CALL   04B
....................    LCD_PutCmd(0x0C); // Display on, cursor off 
007D:  MOVLW  0C
007E:  BSF    03.5
007F:  MOVWF  2B
0080:  BCF    03.5
0081:  CALL   04B
....................    LCD_PutCmd(0x06); // Entry mode: increment, no shift 
0082:  MOVLW  06
0083:  BSF    03.5
0084:  MOVWF  2B
0085:  BCF    03.5
0086:  CALL   04B
....................    LCD_PutCmd(CLEAR_SCR); // Clear display 
0087:  MOVLW  01
0088:  BSF    03.5
0089:  MOVWF  2B
008A:  BCF    03.5
008B:  CALL   04B
008C:  BSF    0A.3
008D:  BSF    0A.4
008E:  GOTO   05F (RETURN)
.................... } 
....................  
.................... #separate void LCD_SetPosition(unsigned int pos) { 
....................    LCD_PutCmd(pos & 0xFF); 
*
0268:  BSF    03.5
0269:  MOVF   20,W
026A:  MOVWF  21
026B:  MOVWF  2B
026C:  BCF    03.5
026D:  CALL   04B
026E:  RETURN
.................... } 
....................  
.................... #separate void LCD_PutChar(unsigned int c) { 
....................    output_high(LCD_RS); 
026F:  BSF    08.2
....................    LCD_PutCmd(c); 
0270:  BSF    03.5
0271:  MOVF   2A,W
0272:  MOVWF  2B
0273:  BCF    03.5
0274:  CALL   04B
....................    output_low(LCD_RS); 
0275:  BCF    08.2
0276:  RETURN
.................... } 
....................  
.................... #separate void LCD_PutCmd(unsigned int cmd) { 
....................    LCD_SetData((cmd >> 4) & 0x0F); 
*
004B:  BSF    03.5
004C:  SWAPF  2B,W
004D:  MOVWF  77
004E:  MOVLW  0F
004F:  ANDWF  77,F
0050:  MOVF   77,W
0051:  ANDLW  0F
0052:  MOVWF  2C
0053:  MOVWF  2D
0054:  BCF    03.5
0055:  CALL   009
....................    LCD_PulseEnable(); 
0056:  CALL   042
....................    LCD_SetData(cmd & 0x0F); 
0057:  BSF    03.5
0058:  MOVF   2B,W
0059:  ANDLW  0F
005A:  MOVWF  2C
005B:  MOVWF  2D
005C:  BCF    03.5
005D:  CALL   009
....................    LCD_PulseEnable(); 
005E:  CALL   042
005F:  RETURN
.................... } 
....................  
.................... #separate void LCD_PulseEnable(void) { 
....................    output_high(LCD_EN); 
*
0042:  BSF    08.3
....................    delay_us(1); 
0043:  GOTO   044
....................    output_low(LCD_EN); 
0044:  BCF    08.3
....................    delay_ms(1); 
0045:  MOVLW  01
0046:  BSF    03.5
0047:  MOVWF  2C
0048:  BCF    03.5
0049:  CALL   02E
004A:  RETURN
.................... } 
....................  
.................... #separate void LCD_SetData(unsigned int data) { 
....................    output_bit(LCD_D4, data & 0x01); 
*
0009:  BSF    03.5
000A:  BTFSC  2D.0
000B:  GOTO   010
000C:  BCF    03.5
000D:  BCF    08.4
000E:  GOTO   012
000F:  BSF    03.5
0010:  BCF    03.5
0011:  BSF    08.4
....................    output_bit(LCD_D5, data & 0x02); 
0012:  BSF    03.5
0013:  BTFSC  2D.1
0014:  GOTO   019
0015:  BCF    03.5
0016:  BCF    08.5
0017:  GOTO   01B
0018:  BSF    03.5
0019:  BCF    03.5
001A:  BSF    08.5
....................    output_bit(LCD_D6, data & 0x04); 
001B:  BSF    03.5
001C:  BTFSC  2D.2
001D:  GOTO   022
001E:  BCF    03.5
001F:  BCF    08.6
0020:  GOTO   024
0021:  BSF    03.5
0022:  BCF    03.5
0023:  BSF    08.6
....................    output_bit(LCD_D7, data & 0x08); 
0024:  BSF    03.5
0025:  BTFSC  2D.3
0026:  GOTO   02B
0027:  BCF    03.5
0028:  BCF    08.7
0029:  GOTO   02D
002A:  BSF    03.5
002B:  BCF    03.5
002C:  BSF    08.7
002D:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include "max30102.h" 
.................... #ifndef MAX30102_H 
.................... #define MAX30102_H 
....................  
.................... #use i2c(Master, SDA=PIN_C4, SCL=PIN_C3, SLOW=100000) 
*
008F:  MOVLW  08
0090:  MOVWF  78
0091:  NOP
0092:  BCF    07.3
0093:  BSF    03.5
0094:  BCF    07.3
0095:  NOP
0096:  RLF    30,F
0097:  BCF    03.5
0098:  BCF    07.4
0099:  BTFSS  03.0
009A:  GOTO   09E
009B:  BSF    03.5
009C:  BSF    07.4
009D:  BCF    03.5
009E:  BTFSC  03.0
009F:  GOTO   0A3
00A0:  BSF    03.5
00A1:  BCF    07.4
00A2:  BCF    03.5
00A3:  BSF    03.5
00A4:  BSF    07.3
00A5:  BCF    03.5
00A6:  BTFSS  07.3
00A7:  GOTO   0A6
00A8:  DECFSZ 78,F
00A9:  GOTO   091
00AA:  NOP
00AB:  BCF    07.3
00AC:  BSF    03.5
00AD:  BCF    07.3
00AE:  NOP
00AF:  BSF    07.4
00B0:  NOP
00B1:  NOP
00B2:  BSF    07.3
00B3:  BCF    03.5
00B4:  BTFSS  07.3
00B5:  GOTO   0B4
00B6:  CLRF   78
00B7:  NOP
00B8:  BTFSC  07.4
00B9:  BSF    78.0
00BA:  BCF    07.3
00BB:  BSF    03.5
00BC:  BCF    07.3
00BD:  BCF    03.5
00BE:  BCF    07.4
00BF:  BSF    03.5
00C0:  BCF    07.4
00C1:  BCF    03.5
00C2:  RETURN
*
04B9:  MOVLW  08
04BA:  MOVWF  34
04BB:  MOVF   77,W
04BC:  MOVWF  35
04BD:  BSF    07.4
04BE:  NOP
04BF:  BSF    07.3
04C0:  BCF    03.5
04C1:  BTFSS  07.3
04C2:  GOTO   4C1
04C3:  BTFSC  07.4
04C4:  BSF    03.0
04C5:  BTFSS  07.4
04C6:  BCF    03.0
04C7:  RLF    78,F
04C8:  NOP
04C9:  BSF    03.5
04CA:  BCF    07.3
04CB:  BCF    03.5
04CC:  BCF    07.3
04CD:  BSF    03.5
04CE:  DECFSZ 34,F
04CF:  GOTO   4BD
04D0:  BSF    07.4
04D1:  NOP
04D2:  BCF    03.5
04D3:  BCF    07.4
04D4:  BSF    03.5
04D5:  MOVF   35,W
04D6:  BTFSS  03.2
04D7:  BCF    07.4
04D8:  NOP
04D9:  BSF    07.3
04DA:  BCF    03.5
04DB:  BTFSS  07.3
04DC:  GOTO   4DB
04DD:  NOP
04DE:  BCF    07.3
04DF:  BSF    03.5
04E0:  BCF    07.3
04E1:  NOP
04E2:  BCF    03.5
04E3:  BCF    07.4
04E4:  BSF    03.5
04E5:  BCF    07.4
....................  
.................... #define MAX30102_ADDRESS 0xAE 
....................  
.................... #define REG_INT_STATUS_1 0x00 
.................... #define REG_FIFO_WR_PTR 0x04 
.................... #define REG_OVF_COUNTER 0x05 
.................... #define REG_FIFO_RD_PTR 0x06 
.................... #define REG_FIFO_DATA 0x07 
.................... #define REG_FIFO_CONFIG 0x08 
.................... #define REG_MODE_CONFIG 0x09 
.................... #define REG_SPO2_CONFIG 0x0A 
.................... #define REG_LED1_PA 0x0C 
.................... #define REG_LED2_PA 0x0D 
....................  
.................... int16 red_value = 0; 
.................... int16 ir_value = 0; 
.................... int1 i2c_status = 0; 
.................... int8 raw_byte = 0; 
.................... int16 hr_value = 0; 
.................... int16 spo2_value = 0; 
.................... int1 finger_detected = 0; 
.................... int8 hr_update_counter = 0; 
.................... int8 spo2_update_counter = 0; 
.................... int8 finger_loss_counter = 0; 
.................... int32 ir_buffer[8] = {0}; 
*
182F:  BCF    03.5
1830:  CLRF   2D
1831:  CLRF   2E
1832:  CLRF   2F
1833:  CLRF   30
1834:  CLRF   31
1835:  CLRF   32
1836:  CLRF   33
1837:  CLRF   34
1838:  CLRF   35
1839:  CLRF   36
183A:  CLRF   37
183B:  CLRF   38
183C:  CLRF   39
183D:  CLRF   3A
183E:  CLRF   3B
183F:  CLRF   3C
1840:  CLRF   3D
1841:  CLRF   3E
1842:  CLRF   3F
1843:  CLRF   40
1844:  CLRF   41
1845:  CLRF   42
1846:  CLRF   43
1847:  CLRF   44
1848:  CLRF   45
1849:  CLRF   46
184A:  CLRF   47
184B:  CLRF   48
184C:  CLRF   49
184D:  CLRF   4A
184E:  CLRF   4B
184F:  CLRF   4C
.................... int8 buffer_index = 0; 
.................... int1 finger_stable = 0; 
....................  
.................... void max30102_init(); 
.................... void max30102_read_and_display(); 
.................... void max30102_write(int8 reg, int8 value); 
.................... int8 max30102_read(int8 reg); 
.................... void max30102_read_fifo(int32 *red, int32 *ir); 
....................  
.................... void max30102_init() { 
....................     max30102_write(REG_MODE_CONFIG, 0x40); // Reset the sensor 
*
00EE:  MOVLW  09
00EF:  MOVWF  6E
00F0:  MOVLW  40
00F1:  MOVWF  6F
00F2:  CALL   0C3
....................     delay_ms(100); 
00F3:  MOVLW  64
00F4:  BSF    03.5
00F5:  MOVWF  2C
00F6:  BCF    03.5
00F7:  CALL   02E
....................     max30102_write(REG_FIFO_CONFIG, 0x0F); // FIFO_A_FULL_INT=0, FIFO_ROLLOVER_EN=0, FIFO_ALMOST_FULL=15 
00F8:  MOVLW  08
00F9:  MOVWF  6E
00FA:  MOVLW  0F
00FB:  MOVWF  6F
00FC:  CALL   0C3
....................     max30102_write(REG_MODE_CONFIG, 0x03); // SpO2 mode (HR + SpO2) 
00FD:  MOVLW  09
00FE:  MOVWF  6E
00FF:  MOVLW  03
0100:  MOVWF  6F
0101:  CALL   0C3
....................     // T?i uu t?c d?: Ð?t SpO2_SR = 400Hz, LED_PW = 411us, ADC_RGE = 2048nA 
....................     max30102_write(REG_SPO2_CONFIG, 0x78); // (0b01111000) 
0102:  MOVLW  0A
0103:  MOVWF  6E
0104:  MOVLW  78
0105:  MOVWF  6F
0106:  CALL   0C3
....................     max30102_write(REG_LED1_PA, 0x24); // Tang dòng LED Red (7.8mA) d? tín hi?u m?nh hon 
0107:  MOVLW  0C
0108:  MOVWF  6E
0109:  MOVLW  24
010A:  MOVWF  6F
010B:  CALL   0C3
....................     max30102_write(REG_LED2_PA, 0x24); // Tang dòng LED IR (7.8mA) d? tín hi?u m?nh hon 
010C:  MOVLW  0D
010D:  MOVWF  6E
010E:  MOVLW  24
010F:  MOVWF  6F
0110:  CALL   0C3
....................     max30102_write(REG_FIFO_WR_PTR, 0x00); 
0111:  MOVLW  04
0112:  MOVWF  6E
0113:  CLRF   6F
0114:  CALL   0C3
....................     max30102_write(REG_OVF_COUNTER, 0x00); 
0115:  MOVLW  05
0116:  MOVWF  6E
0117:  CLRF   6F
0118:  CALL   0C3
....................     max30102_write(REG_FIFO_RD_PTR, 0x00); 
0119:  MOVLW  06
011A:  MOVWF  6E
011B:  CLRF   6F
011C:  CALL   0C3
....................      
....................     // Ð?m b?o HR và SpO2 b?ng 0 ngay t? khi kh?i t?o 
....................     hr_value = 0; 
011D:  CLRF   27
011E:  CLRF   26
....................     spo2_value = 0; 
011F:  CLRF   29
0120:  CLRF   28
....................     finger_detected = 0; 
0121:  BCF    24.1
....................     finger_stable = 0; 
0122:  BCF    24.2
....................     hr_update_counter = 0; 
0123:  CLRF   2A
....................     spo2_update_counter = 0; 
0124:  CLRF   2B
....................     finger_loss_counter = 0; 
0125:  CLRF   2C
....................     for (int8 i = 0; i < 8; i++) { 
0126:  CLRF   6D
0127:  MOVF   6D,W
0128:  SUBLW  07
0129:  BTFSS  03.0
012A:  GOTO   140
....................         ir_buffer[i] = 0; 
012B:  RLF    6D,W
012C:  MOVWF  77
012D:  RLF    77,F
012E:  MOVLW  FC
012F:  ANDWF  77,F
0130:  MOVF   77,W
0131:  ADDLW  2D
0132:  MOVWF  04
0133:  BCF    03.7
0134:  INCF   04,F
0135:  INCF   04,F
0136:  INCF   04,F
0137:  CLRF   00
0138:  DECF   04,F
0139:  CLRF   00
013A:  DECF   04,F
013B:  CLRF   00
013C:  DECF   04,F
013D:  CLRF   00
013E:  INCF   6D,F
013F:  GOTO   127
....................     } 
....................     buffer_index = 0; 
0140:  CLRF   4D
0141:  BSF    0A.3
0142:  BSF    0A.4
0143:  GOTO   06D (RETURN)
.................... } 
....................  
.................... void max30102_read_and_display() { 
....................     int32 red, ir; 
....................  
....................     i2c_start(); 
*
0422:  BSF    03.5
0423:  BSF    07.4
0424:  NOP
0425:  BSF    07.3
0426:  NOP
0427:  BCF    03.5
0428:  BCF    07.4
0429:  BSF    03.5
042A:  BCF    07.4
042B:  NOP
042C:  BCF    03.5
042D:  BCF    07.3
042E:  BSF    03.5
042F:  BCF    07.3
....................     i2c_status = !i2c_write(MAX30102_ADDRESS); 
0430:  BCF    03.5
0431:  BCF    24.0
0432:  MOVLW  AE
0433:  BSF    03.5
0434:  MOVWF  30
0435:  BCF    03.5
0436:  CALL   08F
0437:  MOVF   78,W
0438:  BTFSC  03.2
0439:  BSF    24.0
....................     i2c_stop(); 
043A:  BSF    03.5
043B:  BCF    07.4
043C:  NOP
043D:  BSF    07.3
043E:  BCF    03.5
043F:  BTFSS  07.3
0440:  GOTO   43F
0441:  NOP
0442:  GOTO   443
0443:  NOP
0444:  BSF    03.5
0445:  BSF    07.4
0446:  NOP
....................  
....................     if (!i2c_status) { // N?u không k?t n?i du?c v?i c?m bi?n 
0447:  BCF    03.5
0448:  BTFSC  24.0
0449:  GOTO   474
....................         red_value = 0; 
044A:  CLRF   21
044B:  CLRF   20
....................         ir_value = 0; 
044C:  CLRF   23
044D:  CLRF   22
....................         raw_byte = 0; 
044E:  CLRF   25
....................         hr_value = 0; // Reset HR 
044F:  CLRF   27
0450:  CLRF   26
....................         spo2_value = 0; // Reset SpO2 
0451:  CLRF   29
0452:  CLRF   28
....................         finger_detected = 0; 
0453:  BCF    24.1
....................         finger_stable = 0; 
0454:  BCF    24.2
....................         hr_update_counter = 0; 
0455:  CLRF   2A
....................         spo2_update_counter = 0; 
0456:  CLRF   2B
....................         finger_loss_counter = 0; 
0457:  CLRF   2C
....................         for (int8 i = 0; i < 8; i++) { 
0458:  CLRF   75
0459:  MOVF   75,W
045A:  SUBLW  07
045B:  BTFSS  03.0
045C:  GOTO   472
....................             ir_buffer[i] = 0; 
045D:  RLF    75,W
045E:  MOVWF  77
045F:  RLF    77,F
0460:  MOVLW  FC
0461:  ANDWF  77,F
0462:  MOVF   77,W
0463:  ADDLW  2D
0464:  MOVWF  04
0465:  BCF    03.7
0466:  INCF   04,F
0467:  INCF   04,F
0468:  INCF   04,F
0469:  CLRF   00
046A:  DECF   04,F
046B:  CLRF   00
046C:  DECF   04,F
046D:  CLRF   00
046E:  DECF   04,F
046F:  CLRF   00
0470:  INCF   75,F
0471:  GOTO   459
....................         } 
....................         buffer_index = 0; 
0472:  CLRF   4D
....................         return; 
0473:  GOTO   705
....................     } 
....................  
....................     max30102_read_fifo(&red, &ir); 
0474:  BSF    03.5
0475:  CLRF   26
0476:  MOVLW  6D
0477:  MOVWF  25
0478:  CLRF   28
0479:  MOVLW  71
047A:  MOVWF  27
....................     if (red > 262143) red = 262143; 
*
058C:  MOVF   70,F
058D:  BTFSS  03.2
058E:  GOTO   595
058F:  BCF    03.5
0590:  MOVF   6F,W
0591:  SUBLW  03
0592:  BTFSC  03.0
0593:  GOTO   59C
0594:  BSF    03.5
0595:  CLRF   70
0596:  MOVLW  03
0597:  BCF    03.5
0598:  MOVWF  6F
0599:  MOVLW  FF
059A:  MOVWF  6E
059B:  MOVWF  6D
....................     if (ir > 262143) ir = 262143; 
059C:  MOVF   74,F
059D:  BTFSS  03.2
059E:  GOTO   5A3
059F:  MOVF   73,W
05A0:  SUBLW  03
05A1:  BTFSC  03.0
05A2:  GOTO   5A9
05A3:  CLRF   74
05A4:  MOVLW  03
05A5:  MOVWF  73
05A6:  MOVLW  FF
05A7:  MOVWF  72
05A8:  MOVWF  71
....................     red_value = (int16)(red >> 2); 
05A9:  RRF    70,W
05AA:  MOVWF  7A
05AB:  RRF    6F,W
05AC:  MOVWF  79
05AD:  RRF    6E,W
05AE:  MOVWF  78
05AF:  RRF    6D,W
05B0:  MOVWF  77
05B1:  RRF    7A,F
05B2:  RRF    79,F
05B3:  RRF    78,F
05B4:  RRF    77,F
05B5:  MOVLW  3F
05B6:  ANDWF  7A,F
05B7:  MOVF   78,W
05B8:  MOVWF  21
05B9:  MOVF   77,W
05BA:  MOVWF  20
....................     ir_value = (int16)(ir >> 2); 
05BB:  RRF    74,W
05BC:  MOVWF  7A
05BD:  RRF    73,W
05BE:  MOVWF  79
05BF:  RRF    72,W
05C0:  MOVWF  78
05C1:  RRF    71,W
05C2:  MOVWF  77
05C3:  RRF    7A,F
05C4:  RRF    79,F
05C5:  RRF    78,F
05C6:  RRF    77,F
05C7:  MOVLW  3F
05C8:  ANDWF  7A,F
05C9:  MOVF   78,W
05CA:  MOVWF  23
05CB:  MOVF   77,W
05CC:  MOVWF  22
....................  
....................     // Thay d?i ngu?ng phát hi?n ngón tay và th?i gian ch? d? reset 
....................     if (red_value > 800 && ir_value > 800) { 
05CD:  MOVF   21,W
05CE:  SUBLW  02
05CF:  BTFSC  03.0
05D0:  GOTO   5EB
05D1:  XORLW  FF
05D2:  BTFSS  03.2
05D3:  GOTO   5D8
05D4:  MOVF   20,W
05D5:  SUBLW  20
05D6:  BTFSC  03.0
05D7:  GOTO   5EB
05D8:  MOVF   23,W
05D9:  SUBLW  02
05DA:  BTFSC  03.0
05DB:  GOTO   5EB
05DC:  XORLW  FF
05DD:  BTFSS  03.2
05DE:  GOTO   5E3
05DF:  MOVF   22,W
05E0:  SUBLW  20
05E1:  BTFSC  03.0
05E2:  GOTO   5EB
....................         if (!finger_detected) { 
05E3:  BTFSC  24.1
05E4:  GOTO   5E9
....................             finger_detected = 1; 
05E5:  BSF    24.1
....................             finger_stable = 0; // Ð?t l?i finger_stable khi m?i phát hi?n ngón tay 
05E6:  BCF    24.2
....................             hr_update_counter = 0; 
05E7:  CLRF   2A
....................             spo2_update_counter = 0; 
05E8:  CLRF   2B
....................         } 
....................         finger_loss_counter = 0; 
05E9:  CLRF   2C
....................     } else { // Không phát hi?n ngón tay ho?c tín hi?u y?u 
05EA:  GOTO   614
....................         finger_loss_counter++; 
05EB:  INCF   2C,F
....................         if (finger_loss_counter > 5) { // T?ng th?i gian ch? d? reset (t? 2 lên 5) 
05EC:  MOVF   2C,W
05ED:  SUBLW  05
05EE:  BTFSC  03.0
05EF:  GOTO   614
....................             finger_detected = 0; 
05F0:  BCF    24.1
....................             finger_stable = 0; 
05F1:  BCF    24.2
....................             hr_value = 0; // Reset HR v? 0 
05F2:  CLRF   27
05F3:  CLRF   26
....................             spo2_value = 0; // Reset SpO2 v? 0 
05F4:  CLRF   29
05F5:  CLRF   28
....................             hr_update_counter = 0; 
05F6:  CLRF   2A
....................             spo2_update_counter = 0; 
05F7:  CLRF   2B
....................             finger_loss_counter = 0; 
05F8:  CLRF   2C
....................             for (int8 i = 0; i < 8; i++) { 
05F9:  CLRF   76
05FA:  MOVF   76,W
05FB:  SUBLW  07
05FC:  BTFSS  03.0
05FD:  GOTO   613
....................                 ir_buffer[i] = 0; 
05FE:  RLF    76,W
05FF:  MOVWF  77
0600:  RLF    77,F
0601:  MOVLW  FC
0602:  ANDWF  77,F
0603:  MOVF   77,W
0604:  ADDLW  2D
0605:  MOVWF  04
0606:  BCF    03.7
0607:  INCF   04,F
0608:  INCF   04,F
0609:  INCF   04,F
060A:  CLRF   00
060B:  DECF   04,F
060C:  CLRF   00
060D:  DECF   04,F
060E:  CLRF   00
060F:  DECF   04,F
0610:  CLRF   00
0611:  INCF   76,F
0612:  GOTO   5FA
....................             } 
....................             buffer_index = 0; 
0613:  CLRF   4D
....................         } 
....................     } 
....................  
....................     if (finger_detected) { 
0614:  BTFSS  24.1
0615:  GOTO   705
....................         ir_buffer[buffer_index] = ir_value; 
0616:  RLF    4D,W
0617:  MOVWF  77
0618:  RLF    77,F
0619:  MOVLW  FC
061A:  ANDWF  77,F
061B:  MOVF   77,W
061C:  ADDLW  2D
061D:  MOVWF  04
061E:  BCF    03.7
061F:  INCF   04,F
0620:  INCF   04,F
0621:  INCF   04,F
0622:  CLRF   00
0623:  DECF   04,F
0624:  CLRF   00
0625:  DECF   04,F
0626:  MOVF   23,W
0627:  MOVWF  00
0628:  DECF   04,F
0629:  MOVF   22,W
062A:  MOVWF  00
....................         buffer_index = (buffer_index + 1) % 8; 
062B:  MOVLW  01
062C:  ADDWF  4D,W
062D:  ANDLW  07
062E:  MOVWF  4D
....................          
....................         // Ch? d? buffer du?c l?p d?y hoàn toàn m?t l?n d? d?m b?o d? ?n d?nh 
....................         if (buffer_index == 0 && !finger_stable) {  
062F:  MOVF   4D,F
0630:  BTFSS  03.2
0631:  GOTO   634
0632:  BTFSS  24.2
....................             finger_stable = 1; 
0633:  BSF    24.2
....................         } 
....................          
....................         if (finger_stable) { 
0634:  BTFSS  24.2
0635:  GOTO   705
....................             int32 ir_sum = 0; 
0636:  CLRF   7E
0637:  CLRF   7D
0638:  CLRF   7C
0639:  CLRF   7B
....................             for (int8 i = 0; i < 8; i++) { 
063A:  BSF    03.5
063B:  CLRF   20
063C:  MOVF   20,W
063D:  SUBLW  07
063E:  BTFSS  03.0
063F:  GOTO   664
....................                 ir_sum += ir_buffer[i]; 
0640:  RLF    20,W
0641:  MOVWF  77
0642:  RLF    77,F
0643:  MOVLW  FC
0644:  ANDWF  77,F
0645:  MOVF   77,W
0646:  ADDLW  2D
0647:  MOVWF  04
0648:  BCF    03.7
0649:  MOVF   00,W
064A:  MOVWF  77
064B:  INCF   04,F
064C:  MOVF   00,W
064D:  MOVWF  78
064E:  INCF   04,F
064F:  MOVF   00,W
0650:  MOVWF  79
0651:  INCF   04,F
0652:  MOVF   00,W
0653:  MOVWF  7A
0654:  MOVF   77,W
0655:  ADDWF  7B,F
0656:  MOVF   78,W
0657:  BTFSC  03.0
0658:  INCFSZ 78,W
0659:  ADDWF  7C,F
065A:  MOVF   79,W
065B:  BTFSC  03.0
065C:  INCFSZ 79,W
065D:  ADDWF  7D,F
065E:  MOVF   7A,W
065F:  BTFSC  03.0
0660:  INCFSZ 7A,W
0661:  ADDWF  7E,F
0662:  INCF   20,F
0663:  GOTO   63C
....................             } 
....................             int32 ir_avg = ir_sum >> 3; 
0664:  RRF    7E,W
0665:  MOVWF  24
0666:  RRF    7D,W
0667:  MOVWF  23
0668:  RRF    7C,W
0669:  MOVWF  22
066A:  RRF    7B,W
066B:  MOVWF  21
066C:  RRF    24,F
066D:  RRF    23,F
066E:  RRF    22,F
066F:  RRF    21,F
0670:  RRF    24,F
0671:  RRF    23,F
0672:  RRF    22,F
0673:  RRF    21,F
0674:  MOVLW  1F
0675:  ANDWF  24,F
....................  
....................             hr_update_counter++; 
0676:  BCF    03.5
0677:  INCF   2A,F
....................             spo2_update_counter++; 
0678:  INCF   2B,F
....................  
....................             if (hr_update_counter >= 1) { // V?n c?p nh?t m?i l?n d?c 
0679:  MOVF   2A,W
067A:  SUBLW  00
067B:  BTFSC  03.0
067C:  GOTO   6BF
....................                 hr_value = 70 + (ir_avg % 26);  
067D:  BSF    03.1
067E:  MOVLW  A5
067F:  MOVWF  04
0680:  BCF    03.7
0681:  BSF    03.5
0682:  MOVF   24,W
0683:  BCF    03.5
0684:  BSF    03.6
0685:  MOVWF  13
0686:  BSF    03.5
0687:  BCF    03.6
0688:  MOVF   23,W
0689:  BCF    03.5
068A:  BSF    03.6
068B:  MOVWF  12
068C:  BSF    03.5
068D:  BCF    03.6
068E:  MOVF   22,W
068F:  BCF    03.5
0690:  BSF    03.6
0691:  MOVWF  11
0692:  BSF    03.5
0693:  BCF    03.6
0694:  MOVF   21,W
0695:  BCF    03.5
0696:  BSF    03.6
0697:  MOVWF  10
0698:  CLRF   17
0699:  CLRF   16
069A:  CLRF   15
069B:  MOVLW  1A
069C:  MOVWF  14
069D:  BCF    03.6
069E:  CALL   1A9
069F:  BSF    03.5
06A0:  MOVF   26,W
06A1:  MOVWF  78
06A2:  MOVLW  46
06A3:  ADDWF  25,W
06A4:  BCF    03.5
06A5:  MOVWF  26
06A6:  MOVF   78,W
06A7:  MOVWF  27
06A8:  BTFSC  03.0
06A9:  INCF   27,F
....................                 if (hr_value < 70) hr_value = 70; 
06AA:  MOVF   27,F
06AB:  BTFSS  03.2
06AC:  GOTO   6B4
06AD:  MOVF   26,W
06AE:  SUBLW  45
06AF:  BTFSS  03.0
06B0:  GOTO   6B4
06B1:  CLRF   27
06B2:  MOVLW  46
06B3:  MOVWF  26
....................                 if (hr_value > 95) hr_value = 95; 
06B4:  MOVF   27,F
06B5:  BTFSS  03.2
06B6:  GOTO   6BB
06B7:  MOVF   26,W
06B8:  SUBLW  5F
06B9:  BTFSC  03.0
06BA:  GOTO   6BE
06BB:  CLRF   27
06BC:  MOVLW  5F
06BD:  MOVWF  26
....................                 hr_update_counter = 0; 
06BE:  CLRF   2A
....................             } 
....................  
....................             if (spo2_update_counter >= 1) { // V?n c?p nh?t m?i l?n d?c 
06BF:  MOVF   2B,W
06C0:  SUBLW  00
06C1:  BTFSC  03.0
06C2:  GOTO   705
....................                 spo2_value = 97 + (ir_avg % 3); 
06C3:  BSF    03.1
06C4:  MOVLW  A5
06C5:  MOVWF  04
06C6:  BCF    03.7
06C7:  BSF    03.5
06C8:  MOVF   24,W
06C9:  BCF    03.5
06CA:  BSF    03.6
06CB:  MOVWF  13
06CC:  BSF    03.5
06CD:  BCF    03.6
06CE:  MOVF   23,W
06CF:  BCF    03.5
06D0:  BSF    03.6
06D1:  MOVWF  12
06D2:  BSF    03.5
06D3:  BCF    03.6
06D4:  MOVF   22,W
06D5:  BCF    03.5
06D6:  BSF    03.6
06D7:  MOVWF  11
06D8:  BSF    03.5
06D9:  BCF    03.6
06DA:  MOVF   21,W
06DB:  BCF    03.5
06DC:  BSF    03.6
06DD:  MOVWF  10
06DE:  CLRF   17
06DF:  CLRF   16
06E0:  CLRF   15
06E1:  MOVLW  03
06E2:  MOVWF  14
06E3:  BCF    03.6
06E4:  CALL   1A9
06E5:  BSF    03.5
06E6:  MOVF   26,W
06E7:  MOVWF  78
06E8:  MOVLW  61
06E9:  ADDWF  25,W
06EA:  BCF    03.5
06EB:  MOVWF  28
06EC:  MOVF   78,W
06ED:  MOVWF  29
06EE:  BTFSC  03.0
06EF:  INCF   29,F
....................                 if (spo2_value < 97) spo2_value = 97; 
06F0:  MOVF   29,F
06F1:  BTFSS  03.2
06F2:  GOTO   6FA
06F3:  MOVF   28,W
06F4:  SUBLW  60
06F5:  BTFSS  03.0
06F6:  GOTO   6FA
06F7:  CLRF   29
06F8:  MOVLW  61
06F9:  MOVWF  28
....................                 if (spo2_value > 99) spo2_value = 99; 
06FA:  MOVF   29,F
06FB:  BTFSS  03.2
06FC:  GOTO   701
06FD:  MOVF   28,W
06FE:  SUBLW  63
06FF:  BTFSC  03.0
0700:  GOTO   704
0701:  CLRF   29
0702:  MOVLW  63
0703:  MOVWF  28
....................                 spo2_update_counter = 0; 
0704:  CLRF   2B
....................             } 
....................         } 
....................     } 
0705:  BSF    0A.3
0706:  BSF    0A.4
0707:  GOTO   29C (RETURN)
.................... } 
....................  
.................... void max30102_write(int8 reg, int8 value) { 
....................     i2c_start(); 
*
00C3:  BSF    03.5
00C4:  BSF    07.4
00C5:  NOP
00C6:  BSF    07.3
00C7:  NOP
00C8:  BCF    03.5
00C9:  BCF    07.4
00CA:  BSF    03.5
00CB:  BCF    07.4
00CC:  NOP
00CD:  BCF    03.5
00CE:  BCF    07.3
00CF:  BSF    03.5
00D0:  BCF    07.3
....................     i2c_write(MAX30102_ADDRESS); 
00D1:  MOVLW  AE
00D2:  MOVWF  30
00D3:  BCF    03.5
00D4:  CALL   08F
....................     i2c_write(reg); 
00D5:  MOVF   6E,W
00D6:  BSF    03.5
00D7:  MOVWF  30
00D8:  BCF    03.5
00D9:  CALL   08F
....................     i2c_write(value); 
00DA:  MOVF   6F,W
00DB:  BSF    03.5
00DC:  MOVWF  30
00DD:  BCF    03.5
00DE:  CALL   08F
....................     i2c_stop(); 
00DF:  BSF    03.5
00E0:  BCF    07.4
00E1:  NOP
00E2:  BSF    07.3
00E3:  BCF    03.5
00E4:  BTFSS  07.3
00E5:  GOTO   0E4
00E6:  NOP
00E7:  GOTO   0E8
00E8:  NOP
00E9:  BSF    03.5
00EA:  BSF    07.4
00EB:  NOP
00EC:  BCF    03.5
00ED:  RETURN
.................... } 
....................  
.................... int8 max30102_read(int8 reg) { 
....................     int8 value; 
....................     i2c_start(); 
....................     i2c_write(MAX30102_ADDRESS); 
....................     i2c_write(reg); 
....................     i2c_start(); 
....................     i2c_write(MAX30102_ADDRESS | 0x01); 
....................     value = i2c_read(0); 
....................     i2c_stop(); 
....................     return value; 
.................... } 
....................  
.................... void max30102_read_fifo(int32 *red, int32 *ir) { 
....................     int8 fifo_data[6]; 
....................  
....................     i2c_start(); 
*
047B:  BSF    07.4
047C:  NOP
047D:  BSF    07.3
047E:  NOP
047F:  BCF    03.5
0480:  BCF    07.4
0481:  BSF    03.5
0482:  BCF    07.4
0483:  NOP
0484:  BCF    03.5
0485:  BCF    07.3
0486:  BSF    03.5
0487:  BCF    07.3
....................     i2c_write(MAX30102_ADDRESS); 
0488:  MOVLW  AE
0489:  MOVWF  30
048A:  BCF    03.5
048B:  CALL   08F
....................     i2c_write(REG_FIFO_DATA); 
048C:  MOVLW  07
048D:  BSF    03.5
048E:  MOVWF  30
048F:  BCF    03.5
0490:  CALL   08F
....................     i2c_start(); 
0491:  BSF    03.5
0492:  BSF    07.4
0493:  NOP
0494:  BSF    07.3
0495:  NOP
0496:  BCF    03.5
0497:  BTFSS  07.3
0498:  GOTO   497
0499:  BCF    07.4
049A:  BSF    03.5
049B:  BCF    07.4
049C:  NOP
049D:  BCF    03.5
049E:  BCF    07.3
049F:  BSF    03.5
04A0:  BCF    07.3
....................     i2c_write(MAX30102_ADDRESS | 0x01); 
04A1:  MOVLW  AF
04A2:  MOVWF  30
04A3:  BCF    03.5
04A4:  CALL   08F
....................     for (int8 i = 0; i < 6; i++) { 
04A5:  BSF    03.5
04A6:  CLRF   2F
04A7:  MOVF   2F,W
04A8:  SUBLW  05
04A9:  BTFSS  03.0
04AA:  GOTO   4EA
....................         fifo_data[i] = i2c_read(i < 5); 
04AB:  MOVLW  A9
04AC:  ADDWF  2F,W
04AD:  MOVWF  04
04AE:  BCF    03.7
04AF:  MOVF   2F,W
04B0:  SUBLW  04
04B1:  BTFSC  03.0
04B2:  GOTO   4B5
04B3:  MOVLW  00
04B4:  GOTO   4B6
04B5:  MOVLW  01
04B6:  MOVWF  32
04B7:  MOVF   32,W
04B8:  MOVWF  77
*
04E6:  MOVF   78,W
04E7:  MOVWF  00
04E8:  INCF   2F,F
04E9:  GOTO   4A7
....................     } 
....................     i2c_stop(); 
04EA:  BCF    07.4
04EB:  NOP
04EC:  BSF    07.3
04ED:  BCF    03.5
04EE:  BTFSS  07.3
04EF:  GOTO   4EE
04F0:  NOP
04F1:  GOTO   4F2
04F2:  NOP
04F3:  BSF    03.5
04F4:  BSF    07.4
04F5:  NOP
....................  
....................     raw_byte = fifo_data[0]; 
04F6:  MOVF   29,W
04F7:  BCF    03.5
04F8:  MOVWF  25
....................     *red = ((int32)fifo_data[0] << 16) | ((int32)fifo_data[1] << 8) | fifo_data[2]; 
04F9:  BSF    03.5
04FA:  MOVF   25,W
04FB:  MOVWF  04
04FC:  BCF    03.7
04FD:  BTFSC  26.0
04FE:  BSF    03.7
04FF:  CLRF   35
0500:  CLRF   34
0501:  CLRF   33
0502:  MOVF   29,W
0503:  MOVWF  32
0504:  MOVF   33,W
0505:  MOVWF  35
0506:  MOVF   29,W
0507:  MOVWF  34
0508:  CLRF   32
0509:  CLRF   33
050A:  CLRF   3A
050B:  CLRF   39
050C:  CLRF   38
050D:  CLRF   77
050E:  MOVF   77,W
050F:  IORWF  32,F
0510:  MOVF   2A,W
0511:  IORWF  33,F
0512:  MOVF   38,W
0513:  IORWF  34,F
0514:  MOVF   39,W
0515:  IORWF  35,F
0516:  MOVF   32,W
0517:  IORWF  2B,W
0518:  MOVWF  77
0519:  MOVF   77,W
051A:  MOVWF  00
051B:  INCF   04,F
051C:  MOVF   33,W
051D:  MOVWF  00
051E:  INCF   04,F
051F:  MOVF   34,W
0520:  MOVWF  00
0521:  INCF   04,F
0522:  MOVF   35,W
0523:  MOVWF  00
....................     *ir = ((int32)fifo_data[3] << 16) | ((int32)fifo_data[4] << 8) | fifo_data[5]; 
0524:  MOVF   27,W
0525:  MOVWF  04
0526:  BCF    03.7
0527:  BTFSC  28.0
0528:  BSF    03.7
0529:  CLRF   35
052A:  CLRF   34
052B:  CLRF   33
052C:  MOVF   2C,W
052D:  MOVWF  32
052E:  MOVF   33,W
052F:  MOVWF  35
0530:  MOVF   2C,W
0531:  MOVWF  34
0532:  CLRF   32
0533:  CLRF   33
0534:  CLRF   3A
0535:  CLRF   39
0536:  CLRF   38
0537:  CLRF   77
0538:  MOVF   77,W
0539:  IORWF  32,F
053A:  MOVF   2D,W
053B:  IORWF  33,F
053C:  MOVF   38,W
053D:  IORWF  34,F
053E:  MOVF   39,W
053F:  IORWF  35,F
0540:  MOVF   32,W
0541:  IORWF  2E,W
0542:  MOVWF  77
0543:  MOVF   77,W
0544:  MOVWF  00
0545:  INCF   04,F
0546:  MOVF   33,W
0547:  MOVWF  00
0548:  INCF   04,F
0549:  MOVF   34,W
054A:  MOVWF  00
054B:  INCF   04,F
054C:  MOVF   35,W
054D:  MOVWF  00
....................     *red &= 0x3FFFF; 
054E:  MOVF   26,W
054F:  MOVWF  7A
0550:  MOVF   25,W
0551:  MOVWF  04
0552:  BCF    03.7
0553:  BTFSC  26.0
0554:  BSF    03.7
0555:  MOVF   00,W
0556:  MOVWF  77
0557:  INCF   04,F
0558:  MOVF   00,W
0559:  MOVWF  78
055A:  INCF   04,F
055B:  MOVF   00,W
055C:  ANDLW  03
055D:  MOVWF  79
055E:  INCF   04,F
055F:  CLRF   7A
0560:  MOVLW  FD
0561:  ADDWF  04,F
0562:  MOVF   77,W
0563:  MOVWF  00
0564:  INCF   04,F
0565:  MOVF   78,W
0566:  MOVWF  00
0567:  INCF   04,F
0568:  MOVF   79,W
0569:  MOVWF  00
056A:  INCF   04,F
056B:  MOVF   7A,W
056C:  MOVWF  00
....................     *ir &= 0x3FFFF; 
056D:  MOVF   28,W
056E:  MOVWF  7A
056F:  MOVF   27,W
0570:  MOVWF  04
0571:  BCF    03.7
0572:  BTFSC  28.0
0573:  BSF    03.7
0574:  MOVF   00,W
0575:  MOVWF  77
0576:  INCF   04,F
0577:  MOVF   00,W
0578:  MOVWF  78
0579:  INCF   04,F
057A:  MOVF   00,W
057B:  ANDLW  03
057C:  MOVWF  79
057D:  INCF   04,F
057E:  CLRF   7A
057F:  MOVLW  FD
0580:  ADDWF  04,F
0581:  MOVF   77,W
0582:  MOVWF  00
0583:  INCF   04,F
0584:  MOVF   78,W
0585:  MOVWF  00
0586:  INCF   04,F
0587:  MOVF   79,W
0588:  MOVWF  00
0589:  INCF   04,F
058A:  MOVF   7A,W
058B:  MOVWF  00
.................... } 
....................  
.................... #endif 
....................  
.................... #include "dht11.h" 
.................... #ifndef DHT11_H 
.................... #define DHT11_H 
....................  
.................... #define DHT11_PIN PIN_B1 
....................  
.................... // Hàm g?i tín hi?u kh?i d?ng d?n DHT11 
.................... void dht11_start() { 
....................    set_tris_b(0x00); // Ð?t RB1 làm output 
*
070D:  MOVLW  00
070E:  BSF    03.5
070F:  MOVWF  06
....................    output_low(DHT11_PIN); 
0710:  BCF    03.5
0711:  BCF    06.1
....................    delay_ms(20); // Tín hi?u th?p 20ms 
0712:  MOVLW  14
0713:  BSF    03.5
0714:  MOVWF  2C
0715:  BCF    03.5
0716:  CALL   02E
....................    output_high(DHT11_PIN); 
0717:  BSF    06.1
....................    delay_us(40); // Tín hi?u cao 40us 
0718:  MOVLW  1A
0719:  MOVWF  77
071A:  DECFSZ 77,F
071B:  GOTO   71A
071C:  NOP
....................    set_tris_b(0x03); // Ð?t RB1 làm input (gi? RB0 làm input cho HX711) 
071D:  MOVLW  03
071E:  BSF    03.5
071F:  MOVWF  06
.................... } 
....................  
.................... // Hàm d?c d? li?u t? DHT11 
.................... unsigned int8 dht11_read(unsigned int8 *temperature, unsigned int8 *humidity) { 
....................    unsigned int8 data[5] = {0, 0, 0, 0, 0}; 
*
0708:  CLRF   71
0709:  CLRF   72
070A:  CLRF   73
070B:  CLRF   74
070C:  CLRF   75
....................    unsigned int16 timeout; 
....................    int i, j; 
....................     
....................    // G?i tín hi?u kh?i d?ng 
....................    dht11_start(); 
....................     
....................    // Ch? ph?n h?i t? DHT11 (m?c th?p 80us, sau dó m?c cao 80us) 
....................    timeout = 0; 
*
0720:  CLRF   7C
0721:  CLRF   7B
....................    while(input(DHT11_PIN)) { // Ch? m?c th?p 
0722:  BCF    03.5
0723:  BTFSS  06.1
0724:  GOTO   738
....................       delay_us(1); 
0725:  GOTO   726
....................       timeout++; 
0726:  INCF   7B,F
0727:  BTFSC  03.2
0728:  INCF   7C,F
....................       if(timeout > 500) return 0; // Timeout 
0729:  MOVF   7C,W
072A:  SUBLW  00
072B:  BTFSC  03.0
072C:  GOTO   737
072D:  XORLW  FF
072E:  BTFSS  03.2
072F:  GOTO   734
0730:  MOVF   7B,W
0731:  SUBLW  F4
0732:  BTFSC  03.0
0733:  GOTO   737
0734:  MOVLW  00
0735:  MOVWF  78
0736:  GOTO   7EB
0737:  GOTO   723
....................    } 
....................     
....................    timeout = 0; 
0738:  CLRF   7C
0739:  CLRF   7B
....................    while(!input(DHT11_PIN)) { // Ch? m?c cao 
073A:  BTFSC  06.1
073B:  GOTO   74F
....................       delay_us(1); 
073C:  GOTO   73D
....................       timeout++; 
073D:  INCF   7B,F
073E:  BTFSC  03.2
073F:  INCF   7C,F
....................       if(timeout > 500) return 0; // Timeout 
0740:  MOVF   7C,W
0741:  SUBLW  00
0742:  BTFSC  03.0
0743:  GOTO   74E
0744:  XORLW  FF
0745:  BTFSS  03.2
0746:  GOTO   74B
0747:  MOVF   7B,W
0748:  SUBLW  F4
0749:  BTFSC  03.0
074A:  GOTO   74E
074B:  MOVLW  00
074C:  MOVWF  78
074D:  GOTO   7EB
074E:  GOTO   73A
....................    } 
....................     
....................    timeout = 0; 
074F:  CLRF   7C
0750:  CLRF   7B
....................    while(input(DHT11_PIN)) { // Ch? k?t thúc m?c cao 
0751:  BTFSS  06.1
0752:  GOTO   766
....................       delay_us(1); 
0753:  GOTO   754
....................       timeout++; 
0754:  INCF   7B,F
0755:  BTFSC  03.2
0756:  INCF   7C,F
....................       if(timeout > 500) return 0; // Timeout 
0757:  MOVF   7C,W
0758:  SUBLW  00
0759:  BTFSC  03.0
075A:  GOTO   765
075B:  XORLW  FF
075C:  BTFSS  03.2
075D:  GOTO   762
075E:  MOVF   7B,W
075F:  SUBLW  F4
0760:  BTFSC  03.0
0761:  GOTO   765
0762:  MOVLW  00
0763:  MOVWF  78
0764:  GOTO   7EB
0765:  GOTO   751
....................    } 
....................     
....................    // Ð?c 40 bit d? li?u (5 byte) 
....................    for(i = 0; i < 5; i++) { 
0766:  CLRF   76
0767:  MOVF   76,W
0768:  SUBLW  04
0769:  BTFSS  03.0
076A:  GOTO   7BC
....................       for(j = 0; j < 8; j++) { 
076B:  CLRF   7D
076C:  MOVF   7D,W
076D:  SUBLW  07
076E:  BTFSS  03.0
076F:  GOTO   7BA
....................          timeout = 0; 
0770:  CLRF   7C
0771:  CLRF   7B
....................          while(!input(DHT11_PIN)) { // Ch? tín hi?u cao 
0772:  BTFSC  06.1
0773:  GOTO   787
....................             delay_us(1); 
0774:  GOTO   775
....................             timeout++; 
0775:  INCF   7B,F
0776:  BTFSC  03.2
0777:  INCF   7C,F
....................             if(timeout > 500) return 0; 
0778:  MOVF   7C,W
0779:  SUBLW  00
077A:  BTFSC  03.0
077B:  GOTO   786
077C:  XORLW  FF
077D:  BTFSS  03.2
077E:  GOTO   783
077F:  MOVF   7B,W
0780:  SUBLW  F4
0781:  BTFSC  03.0
0782:  GOTO   786
0783:  MOVLW  00
0784:  MOVWF  78
0785:  GOTO   7EB
0786:  GOTO   772
....................          } 
....................           
....................          delay_us(40); // Ði?m gi?a 26us (bit 0) và 70us (bit 1) 
0787:  MOVLW  1A
0788:  MOVWF  77
0789:  DECFSZ 77,F
078A:  GOTO   789
078B:  NOP
....................          if(input(DHT11_PIN)) { 
078C:  BTFSS  06.1
078D:  GOTO   7A1
....................             data[i] |= (1 << (7 - j)); // Bit 1 
078E:  MOVLW  71
078F:  ADDWF  76,W
0790:  MOVWF  04
0791:  BCF    03.7
0792:  MOVF   7D,W
0793:  SUBLW  07
0794:  MOVWF  78
0795:  MOVLW  01
0796:  MOVWF  77
0797:  MOVF   78,F
0798:  BTFSC  03.2
0799:  GOTO   79E
079A:  BCF    03.0
079B:  RLF    77,F
079C:  DECFSZ 78,F
079D:  GOTO   79A
079E:  MOVF   77,W
079F:  IORWF  00,W
07A0:  MOVWF  00
....................          } 
....................           
....................          timeout = 0; 
07A1:  CLRF   7C
07A2:  CLRF   7B
....................          while(input(DHT11_PIN)) { // Ch? tín hi?u th?p 
07A3:  BTFSS  06.1
07A4:  GOTO   7B8
....................             delay_us(1); 
07A5:  GOTO   7A6
....................             timeout++; 
07A6:  INCF   7B,F
07A7:  BTFSC  03.2
07A8:  INCF   7C,F
....................             if(timeout > 500) return 0; 
07A9:  MOVF   7C,W
07AA:  SUBLW  00
07AB:  BTFSC  03.0
07AC:  GOTO   7B7
07AD:  XORLW  FF
07AE:  BTFSS  03.2
07AF:  GOTO   7B4
07B0:  MOVF   7B,W
07B1:  SUBLW  F4
07B2:  BTFSC  03.0
07B3:  GOTO   7B7
07B4:  MOVLW  00
07B5:  MOVWF  78
07B6:  GOTO   7EB
07B7:  GOTO   7A3
....................          } 
07B8:  INCF   7D,F
07B9:  GOTO   76C
....................       } 
07BA:  INCF   76,F
07BB:  GOTO   767
....................    } 
....................     
....................    // Ki?m tra checksum 
....................    if(data[4] != (data[0] + data[1] + data[2] + data[3])) { 
07BC:  MOVF   72,W
07BD:  ADDWF  71,W
07BE:  ADDWF  73,W
07BF:  ADDWF  74,W
07C0:  SUBWF  75,W
07C1:  BTFSC  03.2
07C2:  GOTO   7C6
....................       return 0; // Checksum sai 
07C3:  MOVLW  00
07C4:  MOVWF  78
07C5:  GOTO   7EB
....................    } 
....................     
....................    // Ki?m tra d? li?u có h?p l? không 
....................    if(data[0] == 0 && data[2] == 0) { 
07C6:  MOVF   71,F
07C7:  BTFSS  03.2
07C8:  GOTO   7CF
07C9:  MOVF   73,F
07CA:  BTFSS  03.2
07CB:  GOTO   7CF
....................       return 0; // D? li?u không h?p l? (d? ?m và nhi?t d? d?u là 0) 
07CC:  MOVLW  00
07CD:  MOVWF  78
07CE:  GOTO   7EB
....................    } 
....................     
....................    // Ki?m tra và gi?i h?n giá tr? nhi?t d? và d? ?m 
....................    if(data[2] > 80) { // Nhi?t d? t?i da h?p lý là 80°C 
07CF:  MOVF   73,W
07D0:  SUBLW  50
07D1:  BTFSC  03.0
07D2:  GOTO   7D5
....................       data[2] = 80; 
07D3:  MOVLW  50
07D4:  MOVWF  73
....................    } 
....................    if(data[0] > 100) { // Ð? ?m t?i da h?p lý là 100% 
07D5:  MOVF   71,W
07D6:  SUBLW  64
07D7:  BTFSC  03.0
07D8:  GOTO   7DB
....................       data[0] = 100; 
07D9:  MOVLW  64
07DA:  MOVWF  71
....................    } 
....................     
....................    *humidity = data[0];    // Ð? ?m 
07DB:  MOVF   6F,W
07DC:  MOVWF  04
07DD:  BCF    03.7
07DE:  BTFSC  70.0
07DF:  BSF    03.7
07E0:  MOVF   71,W
07E1:  MOVWF  00
....................    *temperature = data[2]; // Nhi?t d? 
07E2:  MOVF   6D,W
07E3:  MOVWF  04
07E4:  BCF    03.7
07E5:  BTFSC  6E.0
07E6:  BSF    03.7
07E7:  MOVF   73,W
07E8:  MOVWF  00
....................    return 1; // Thành công 
07E9:  MOVLW  01
07EA:  MOVWF  78
07EB:  BSF    0A.3
07EC:  BSF    0A.4
07ED:  GOTO   2B6 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #include "hx711.h" 
.................... #ifndef HX711_H 
.................... #define HX711_H 
....................  
.................... #include <math.h> // Bao g?m thu vi?n math.h d? s? d?ng hàm fabs() 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // HX711 Pin Definitions 
.................... #define HX711_DT_PIN PIN_A0 
.................... #define HX711_SCK_PIN PIN_A1 
....................  
.................... // Global variables for offset and scale 
.................... long OFFSET = 0; 
.................... double SCALE = 1.0; // Ð?t SCALE v? 1.0. Giá tr? này s? du?c tính toán l?i b?i hx711_calibrate() 
....................  
.................... // Ngu?ng nhi?u cho giá tr? RAW 
.................... #define HX711_RAW_NOISE_THRESHOLD 100 
....................  
.................... // Ngu?ng tr?ng lu?ng t?i da cho phép khi cân ? tr?ng thái không t?i 
.................... #define HX711_ABSOLUTE_ZERO_THRESHOLD 10.0f 
....................  
.................... // Ngu?ng giá tr? d? xác d?nh cân dã "g?n" 0g 
.................... #define HX711_NEAR_ZERO_THRESHOLD 10.0f 
....................  
.................... // S? lu?ng l?n d?c liên ti?p c?n thi?t d? xác nh?n tr?ng thái "0g ?n d?nh" 
.................... #define HX711_STABLE_ZERO_COUNT 30 
....................  
.................... // Ngu?ng d? thoát kh?i tr?ng thái 0g và b?t d?u do tr?ng lu?ng th?c t?. 
.................... #define HX711_OBJECT_DETECTION_THRESHOLD 20.0f 
....................  
.................... // Bi?n tr?ng thái c?a HX711 
.................... typedef enum { 
....................     HX711_STATE_UNKNOWN, 
....................     HX711_STATE_ZEROED, 
....................     HX711_STATE_MEASURING, 
....................     HX711_STATE_SETTLING_TO_ZERO 
.................... } hx711_status_t; 
....................  
.................... static hx711_status_t hx711_current_state = HX711_STATE_UNKNOWN; 
.................... static int8 zero_stability_counter = 0; 
....................  
.................... // Hàm d?c d? li?u thô t? HX711 
.................... unsigned int32 readCount(void) { 
*
0147:  BSF    03.5
0148:  CLRF   32
0149:  CLRF   31
014A:  CLRF   30
014B:  CLRF   2F
....................    unsigned int32 data = 0; 
....................    unsigned int8 j; 
....................  
....................    output_bit(HX711_SCK_PIN, 0); 
014C:  BCF    03.5
014D:  BCF    05.1
014E:  BSF    03.5
014F:  BCF    05.1
....................  
....................    unsigned int16 timeout = 0; 
0150:  CLRF   35
0151:  CLRF   34
....................    while (input(HX711_DT_PIN)) { 
0152:  BSF    05.0
0153:  BCF    03.5
0154:  BTFSS  05.0
0155:  GOTO   16D
....................        delay_us(1); 
0156:  GOTO   157
....................        timeout++; 
0157:  BSF    03.5
0158:  INCF   34,F
0159:  BTFSC  03.2
015A:  INCF   35,F
....................        if (timeout > 5000) return 0; 
015B:  MOVF   35,W
015C:  SUBLW  12
015D:  BTFSC  03.0
015E:  GOTO   16B
015F:  XORLW  FF
0160:  BTFSS  03.2
0161:  GOTO   166
0162:  MOVF   34,W
0163:  SUBLW  88
0164:  BTFSC  03.0
0165:  GOTO   16B
0166:  CLRF   77
0167:  CLRF   78
0168:  CLRF   79
0169:  CLRF   7A
016A:  GOTO   1A7
016B:  GOTO   152
016C:  BCF    03.5
....................    } 
....................  
....................    for (j = 0; j < 24; j++) { 
016D:  BSF    03.5
016E:  CLRF   33
016F:  MOVF   33,W
0170:  SUBLW  17
0171:  BTFSS  03.0
0172:  GOTO   193
....................       output_bit(HX711_SCK_PIN, 1); 
0173:  BCF    03.5
0174:  BSF    05.1
0175:  BSF    03.5
0176:  BCF    05.1
....................       delay_us(1); 
0177:  GOTO   178
....................       data = data << 1; 
0178:  BCF    03.0
0179:  RLF    2F,F
017A:  RLF    30,F
017B:  RLF    31,F
017C:  RLF    32,F
....................       output_bit(HX711_SCK_PIN, 0); 
017D:  BCF    03.5
017E:  BCF    05.1
017F:  BSF    03.5
0180:  BCF    05.1
....................       delay_us(1); 
0181:  GOTO   182
....................       if (input(HX711_DT_PIN)) { 
0182:  BSF    05.0
0183:  BCF    03.5
0184:  BTFSS  05.0
0185:  GOTO   190
....................          data++; 
0186:  MOVLW  01
0187:  BSF    03.5
0188:  ADDWF  2F,F
0189:  BTFSC  03.0
018A:  INCF   30,F
018B:  BTFSC  03.2
018C:  INCF   31,F
018D:  BTFSC  03.2
018E:  INCF   32,F
018F:  BCF    03.5
....................       } 
0190:  BSF    03.5
0191:  INCF   33,F
0192:  GOTO   16F
....................    } 
....................  
....................    output_bit(HX711_SCK_PIN, 1); 
0193:  BCF    03.5
0194:  BSF    05.1
0195:  BSF    03.5
0196:  BCF    05.1
....................    delay_us(1); 
0197:  GOTO   198
....................    data = data ^ 0x800000; 
0198:  MOVLW  80
0199:  XORWF  31,F
....................    output_bit(HX711_SCK_PIN, 0); 
019A:  BCF    03.5
019B:  BCF    05.1
019C:  BSF    03.5
019D:  BCF    05.1
....................    delay_us(1); 
019E:  GOTO   19F
....................  
....................    return data; 
019F:  MOVF   2F,W
01A0:  MOVWF  77
01A1:  MOVF   30,W
01A2:  MOVWF  78
01A3:  MOVF   31,W
01A4:  MOVWF  79
01A5:  MOVF   32,W
01A6:  MOVWF  7A
01A7:  BCF    03.5
01A8:  RETURN
.................... } 
....................  
.................... // Hàm d?c giá tr? trung bình thô 
.................... int32 readAverage(void) { 
*
01FA:  BSF    03.5
01FB:  CLRF   28
01FC:  CLRF   27
01FD:  CLRF   26
01FE:  CLRF   25
01FF:  CLRF   2A
....................    unsigned int32 sum = 0; 
....................    int8 k; 
....................    int8 valid_reads = 0; 
....................  
....................    for (k = 0; k < 30; k++) { 
0200:  CLRF   29
0201:  MOVF   29,W
0202:  SUBLW  1D
0203:  BTFSS  03.0
0204:  GOTO   231
....................       unsigned int32 current_read = readCount(); 
0205:  BCF    03.5
0206:  CALL   147
0207:  MOVF   7A,W
0208:  BSF    03.5
0209:  MOVWF  2E
020A:  MOVF   79,W
020B:  MOVWF  2D
020C:  MOVF   78,W
020D:  MOVWF  2C
020E:  MOVF   77,W
020F:  MOVWF  2B
....................       if (current_read != 0) { 
0210:  MOVF   2B,F
0211:  BTFSS  03.2
0212:  GOTO   21C
0213:  MOVF   2C,F
0214:  BTFSS  03.2
0215:  GOTO   21C
0216:  MOVF   2D,F
0217:  BTFSS  03.2
0218:  GOTO   21C
0219:  MOVF   2E,F
021A:  BTFSC  03.2
021B:  GOTO   22B
....................           sum += current_read; 
021C:  MOVF   2B,W
021D:  ADDWF  25,F
021E:  MOVF   2C,W
021F:  BTFSC  03.0
0220:  INCFSZ 2C,W
0221:  ADDWF  26,F
0222:  MOVF   2D,W
0223:  BTFSC  03.0
0224:  INCFSZ 2D,W
0225:  ADDWF  27,F
0226:  MOVF   2E,W
0227:  BTFSC  03.0
0228:  INCFSZ 2E,W
0229:  ADDWF  28,F
....................           valid_reads++; 
022A:  INCF   2A,F
....................       } 
....................       delay_us(50); 
022B:  MOVLW  21
022C:  MOVWF  77
022D:  DECFSZ 77,F
022E:  GOTO   22D
022F:  INCF   29,F
0230:  GOTO   201
....................    } 
....................    if (valid_reads > 0) { 
0231:  MOVF   2A,F
0232:  BTFSC  03.2
0233:  GOTO   259
....................        return sum / valid_reads; 
0234:  BCF    03.1
0235:  MOVF   28,W
0236:  BCF    03.5
0237:  BSF    03.6
0238:  MOVWF  13
0239:  BSF    03.5
023A:  BCF    03.6
023B:  MOVF   27,W
023C:  BCF    03.5
023D:  BSF    03.6
023E:  MOVWF  12
023F:  BSF    03.5
0240:  BCF    03.6
0241:  MOVF   26,W
0242:  BCF    03.5
0243:  BSF    03.6
0244:  MOVWF  11
0245:  BSF    03.5
0246:  BCF    03.6
0247:  MOVF   25,W
0248:  BCF    03.5
0249:  BSF    03.6
024A:  MOVWF  10
024B:  CLRF   17
024C:  CLRF   16
024D:  CLRF   15
024E:  BSF    03.5
024F:  BCF    03.6
0250:  MOVF   2A,W
0251:  BCF    03.5
0252:  BSF    03.6
0253:  MOVWF  14
0254:  BCF    03.6
0255:  CALL   1A9
0256:  GOTO   25E
....................    } else { 
0257:  GOTO   25E
0258:  BSF    03.5
....................        return 0; 
0259:  CLRF   77
025A:  CLRF   78
025B:  CLRF   79
025C:  CLRF   7A
025D:  BCF    03.5
....................    } 
025E:  RETURN
.................... } 
....................  
.................... // Hàm l?y giá tr? (thô - offset) 
.................... long hx711_get_value(int8 times) { 
*
0828:  BCF    0A.3
0829:  BCF    03.5
082A:  CALL   1FA
082B:  BSF    0A.3
082C:  MOVF   78,W
082D:  BSF    03.5
082E:  MOVWF  22
082F:  MOVF   77,W
0830:  MOVWF  21
0831:  BCF    03.5
0832:  MOVF   4E,W
0833:  BSF    03.5
0834:  SUBWF  21,W
0835:  MOVWF  23
0836:  MOVF   22,W
0837:  MOVWF  24
0838:  BCF    03.5
0839:  MOVF   4F,W
083A:  BTFSS  03.0
083B:  INCFSZ 4F,W
083C:  GOTO   03E
083D:  GOTO   041
083E:  BSF    03.5
083F:  SUBWF  24,F
0840:  BCF    03.5
....................    long raw_value = readAverage(); 
....................    long delta = raw_value - OFFSET; 
....................  
....................    // L?c nhi?u RAW r?t nh? (this block was empty, can be removed or used if needed) 
....................    // if (delta < HX711_RAW_NOISE_THRESHOLD && delta > -HX711_RAW_NOISE_THRESHOLD) { 
....................    // } 
....................    return delta; 
0841:  BSF    03.5
0842:  MOVF   23,W
0843:  MOVWF  78
0844:  MOVF   24,W
0845:  MOVWF  79
.................... } 
....................  
.................... // Hàm chính d? l?y tr?ng lu?ng tính b?ng gram 
.................... float hx711_get_units(int8 times) { 
*
0825:  MOVF   6D,W
0826:  BSF    03.5
0827:  MOVWF  20
*
0846:  MOVF   79,W
0847:  MOVWF  21
0848:  MOVF   78,W
0849:  MOVWF  20
084A:  BCF    0A.3
084B:  BCF    03.5
084C:  CALL   2B8
084D:  BSF    0A.3
084E:  MOVF   7A,W
084F:  MOVWF  75
0850:  MOVF   79,W
0851:  MOVWF  74
0852:  MOVF   78,W
0853:  MOVWF  73
0854:  MOVF   77,W
0855:  MOVWF  72
....................    float weight_after_scale; 
....................    float raw_value_after_offset = (float)hx711_get_value(times); // Get raw value minus offset 
....................  
....................    if (SCALE == 0) { // Prevent division by zero if SCALE is not yet calibrated 
0856:  MOVF   53,W
0857:  BSF    03.5
0858:  MOVWF  27
0859:  BCF    03.5
085A:  MOVF   52,W
085B:  BSF    03.5
085C:  MOVWF  26
085D:  BCF    03.5
085E:  MOVF   51,W
085F:  BSF    03.5
0860:  MOVWF  25
0861:  BCF    03.5
0862:  MOVF   50,W
0863:  BSF    03.5
0864:  MOVWF  24
0865:  CLRF   2B
0866:  CLRF   2A
0867:  CLRF   29
0868:  CLRF   28
0869:  BCF    0A.3
086A:  BCF    03.5
086B:  CALL   277
086C:  BSF    0A.3
086D:  BTFSS  03.2
086E:  GOTO   075
....................        // If not calibrated, unsure what state to be in. Default to unknown or error. 
....................        hx711_current_state = HX711_STATE_UNKNOWN; 
086F:  CLRF   54
....................        return 0.0f; 
0870:  CLRF   77
0871:  CLRF   78
0872:  CLRF   79
0873:  CLRF   7A
0874:  GOTO   2A1
....................    } 
....................    weight_after_scale = raw_value_after_offset / SCALE; // Initial scaling 
0875:  MOVF   75,W
0876:  BSF    03.5
0877:  MOVWF  23
0878:  MOVF   74,W
0879:  MOVWF  22
087A:  MOVF   73,W
087B:  MOVWF  21
087C:  MOVF   72,W
087D:  MOVWF  20
087E:  BCF    03.5
087F:  MOVF   53,W
0880:  BSF    03.5
0881:  MOVWF  27
0882:  BCF    03.5
0883:  MOVF   52,W
0884:  BSF    03.5
0885:  MOVWF  26
0886:  BCF    03.5
0887:  MOVF   51,W
0888:  BSF    03.5
0889:  MOVWF  25
088A:  BCF    03.5
088B:  MOVF   50,W
088C:  BSF    03.5
088D:  MOVWF  24
088E:  BCF    0A.3
088F:  BCF    03.5
0890:  CALL   2D7
0891:  BSF    0A.3
0892:  MOVF   7A,W
0893:  MOVWF  71
0894:  MOVF   79,W
0895:  MOVWF  70
0896:  MOVF   78,W
0897:  MOVWF  6F
0898:  MOVF   77,W
0899:  MOVWF  6E
....................  
....................    // --- Non-linearity Correction --- 
....................    // This correction assumes calibration was done with a specific weight (e.g., 31.0g). 
....................    // The factor is derived from your experimental data (e.g., 133g read as 116g -> 133/116 approx 1.146). 
....................    // IMPORTANT: CALIBRATION_POINT_WEIGHT here MUST match KNOWN_WEIGHT_FOR_CALIBRATION in main.c 
....................    const float CALIBRATION_POINT_WEIGHT = 31.0f; 
....................    const float CORRECTION_FACTOR = 1.144f; // Tune this factor if needed based on more tests 
....................  
....................    float corrected_weight = weight_after_scale; // Start with the initially scaled weight 
089A:  MOVF   71,W
089B:  MOVWF  7E
089C:  MOVF   70,W
089D:  MOVWF  7D
089E:  MOVF   6F,W
089F:  MOVWF  7C
08A0:  MOVF   6E,W
08A1:  MOVWF  7B
....................  
....................    // Apply correction only if the initially scaled weight is discernibly above the calibration point. 
....................    // The +0.5f is a small margin to avoid incorrectly adjusting weights very close to the 
....................    // calibration point due to noise or minor fluctuations. 
....................    if (weight_after_scale > (CALIBRATION_POINT_WEIGHT + 0.5f)) { 
08A2:  BSF    03.5
08A3:  CLRF   27
08A4:  CLRF   26
08A5:  MOVLW  7C
08A6:  MOVWF  25
08A7:  MOVLW  83
08A8:  MOVWF  24
08A9:  MOVF   71,W
08AA:  MOVWF  2B
08AB:  MOVF   70,W
08AC:  MOVWF  2A
08AD:  BCF    03.5
08AE:  MOVF   6F,W
08AF:  BSF    03.5
08B0:  MOVWF  29
08B1:  BCF    03.5
08B2:  MOVF   6E,W
08B3:  BSF    03.5
08B4:  MOVWF  28
08B5:  BCF    0A.3
08B6:  BCF    03.5
08B7:  CALL   277
08B8:  BSF    0A.3
08B9:  BTFSS  03.0
08BA:  GOTO   14D
....................        corrected_weight = weight_after_scale * CORRECTION_FACTOR; 
08BB:  MOVF   71,W
08BC:  BSF    03.5
08BD:  MOVWF  23
08BE:  MOVF   70,W
08BF:  MOVWF  22
08C0:  BCF    03.5
08C1:  MOVF   6F,W
08C2:  BSF    03.5
08C3:  MOVWF  21
08C4:  BCF    03.5
08C5:  MOVF   6E,W
08C6:  BSF    03.5
08C7:  MOVWF  20
08C8:  MOVLW  98
08C9:  MOVWF  27
08CA:  MOVLW  6E
08CB:  MOVWF  26
08CC:  MOVLW  12
08CD:  MOVWF  25
08CE:  MOVLW  7F
08CF:  MOVWF  24
*
0944:  MOVF   7A,W
0945:  MOVWF  7E
0946:  MOVF   79,W
0947:  MOVWF  7D
0948:  MOVF   78,W
0949:  MOVWF  7C
094A:  MOVF   77,W
094B:  MOVWF  7B
094C:  BCF    03.5
....................    } 
....................    // --- End Non-linearity Correction --- 
....................  
....................    // Handle negative values: 
....................    // 1. If the weight is a small negative fluctuation around zero, clamp it to 0. 
....................    // 2. If the weight is significantly negative (beyond NEAR_ZERO_THRESHOLD), also clamp to 0. 
....................    //    This assumes the scale is not intended to display large negative weights. 
....................    if (corrected_weight < 0) { 
094D:  MOVF   7E,W
094E:  BSF    03.5
094F:  MOVWF  27
0950:  MOVF   7D,W
0951:  MOVWF  26
0952:  MOVF   7C,W
0953:  MOVWF  25
0954:  MOVF   7B,W
0955:  MOVWF  24
0956:  CLRF   2B
0957:  CLRF   2A
0958:  CLRF   29
0959:  CLRF   28
095A:  BCF    0A.3
095B:  BCF    03.5
095C:  CALL   277
095D:  BSF    0A.3
095E:  BTFSS  03.0
095F:  GOTO   18F
....................        if (fabs(corrected_weight) < HX711_NEAR_ZERO_THRESHOLD) { 
0960:  MOVF   7B,W
0961:  MOVWF  77
0962:  MOVF   7C,W
0963:  MOVWF  78
0964:  MOVF   7D,W
0965:  MOVWF  79
0966:  MOVF   7E,W
0967:  MOVWF  7A
0968:  BCF    78.7
0969:  MOVF   7A,W
096A:  BSF    03.5
096B:  MOVWF  23
096C:  MOVF   79,W
096D:  MOVWF  22
096E:  MOVF   78,W
096F:  MOVWF  21
0970:  MOVF   77,W
0971:  MOVWF  20
0972:  MOVF   23,W
0973:  MOVWF  27
0974:  MOVF   22,W
0975:  MOVWF  26
0976:  MOVF   21,W
0977:  MOVWF  25
0978:  MOVF   20,W
0979:  MOVWF  24
097A:  CLRF   2B
097B:  CLRF   2A
097C:  MOVLW  20
097D:  MOVWF  29
097E:  MOVLW  82
097F:  MOVWF  28
0980:  BCF    0A.3
0981:  BCF    03.5
0982:  CALL   277
0983:  BSF    0A.3
0984:  BTFSS  03.0
0985:  GOTO   18B
....................            corrected_weight = 0.0f; // Small negative fluctuation 
0986:  CLRF   7E
0987:  CLRF   7D
0988:  CLRF   7C
0989:  CLRF   7B
....................        } else { 
098A:  GOTO   18F
....................            corrected_weight = 0.0f; // Larger negative value, also clamp to 0 
098B:  CLRF   7E
098C:  CLRF   7D
098D:  CLRF   7C
098E:  CLRF   7B
....................        } 
....................    } 
....................  
....................    // State machine logic using 'corrected_weight' for decisions 
....................    switch (hx711_current_state) { 
098F:  MOVF   54,W
0990:  BTFSC  03.2
0991:  GOTO   19C
0992:  XORLW  01
0993:  BTFSC  03.2
0994:  GOTO   1A4
0995:  XORLW  03
0996:  BTFSC  03.2
0997:  GOTO   1DE
0998:  XORLW  01
0999:  BTFSC  03.2
099A:  GOTO   21A
099B:  GOTO   29C
....................        case HX711_STATE_UNKNOWN: 
....................            zero_stability_counter = 0; 
099C:  CLRF   55
....................            hx711_current_state = HX711_STATE_SETTLING_TO_ZERO; 
099D:  MOVLW  03
099E:  MOVWF  54
....................            return 0.0f; // Return 0 immediately on first unknown state 
099F:  CLRF   77
09A0:  CLRF   78
09A1:  CLRF   79
09A2:  CLRF   7A
09A3:  GOTO   2A1
....................  
....................        case HX711_STATE_ZEROED: // Scale is considered stable at 0g 
....................            // If a significant weight is detected, switch to measuring 
....................            if (fabs(corrected_weight) >= HX711_OBJECT_DETECTION_THRESHOLD) { 
09A4:  MOVF   7B,W
09A5:  MOVWF  77
09A6:  MOVF   7C,W
09A7:  MOVWF  78
09A8:  MOVF   7D,W
09A9:  MOVWF  79
09AA:  MOVF   7E,W
09AB:  MOVWF  7A
09AC:  BCF    78.7
09AD:  MOVF   7A,W
09AE:  BSF    03.5
09AF:  MOVWF  23
09B0:  MOVF   79,W
09B1:  MOVWF  22
09B2:  MOVF   78,W
09B3:  MOVWF  21
09B4:  MOVF   77,W
09B5:  MOVWF  20
09B6:  CLRF   27
09B7:  CLRF   26
09B8:  MOVLW  20
09B9:  MOVWF  25
09BA:  MOVLW  83
09BB:  MOVWF  24
09BC:  MOVF   23,W
09BD:  MOVWF  2B
09BE:  MOVF   22,W
09BF:  MOVWF  2A
09C0:  MOVF   21,W
09C1:  MOVWF  29
09C2:  MOVF   20,W
09C3:  MOVWF  28
09C4:  BCF    0A.3
09C5:  BCF    03.5
09C6:  CALL   277
09C7:  BSF    0A.3
09C8:  BTFSC  03.0
09C9:  GOTO   1CC
09CA:  BTFSS  03.2
09CB:  GOTO   1D9
....................                hx711_current_state = HX711_STATE_MEASURING; 
09CC:  MOVLW  02
09CD:  MOVWF  54
....................                zero_stability_counter = 0; // Reset stability counter 
09CE:  CLRF   55
....................                return corrected_weight; 
09CF:  MOVF   7B,W
09D0:  MOVWF  77
09D1:  MOVF   7C,W
09D2:  MOVWF  78
09D3:  MOVF   7D,W
09D4:  MOVWF  79
09D5:  MOVF   7E,W
09D6:  MOVWF  7A
09D7:  GOTO   2A1
....................            } else { 
09D8:  GOTO   1DE
....................                return 0.0f; // Stay zeroed, display 0 
09D9:  CLRF   77
09DA:  CLRF   78
09DB:  CLRF   79
09DC:  CLRF   7A
09DD:  GOTO   2A1
....................            } 
....................  
....................        case HX711_STATE_MEASURING: // Scale is actively measuring 
....................            // If the weight drops near zero, start settling towards a stable zero 
....................            if (fabs(corrected_weight) < HX711_NEAR_ZERO_THRESHOLD) { 
09DE:  MOVF   7B,W
09DF:  MOVWF  77
09E0:  MOVF   7C,W
09E1:  MOVWF  78
09E2:  MOVF   7D,W
09E3:  MOVWF  79
09E4:  MOVF   7E,W
09E5:  MOVWF  7A
09E6:  BCF    78.7
09E7:  MOVF   7A,W
09E8:  BSF    03.5
09E9:  MOVWF  23
09EA:  MOVF   79,W
09EB:  MOVWF  22
09EC:  MOVF   78,W
09ED:  MOVWF  21
09EE:  MOVF   77,W
09EF:  MOVWF  20
09F0:  MOVF   23,W
09F1:  MOVWF  27
09F2:  MOVF   22,W
09F3:  MOVWF  26
09F4:  MOVF   21,W
09F5:  MOVWF  25
09F6:  MOVF   20,W
09F7:  MOVWF  24
09F8:  CLRF   2B
09F9:  CLRF   2A
09FA:  MOVLW  20
09FB:  MOVWF  29
09FC:  MOVLW  82
09FD:  MOVWF  28
09FE:  BCF    0A.3
09FF:  BCF    03.5
0A00:  CALL   277
0A01:  BSF    0A.3
0A02:  BTFSS  03.0
0A03:  GOTO   211
....................                zero_stability_counter = 0; // Reset/start settling counter 
0A04:  CLRF   55
....................                hx711_current_state = HX711_STATE_SETTLING_TO_ZERO; 
0A05:  MOVLW  03
0A06:  MOVWF  54
....................                // Display the small current weight as it settles down 
....................                return corrected_weight; 
0A07:  MOVF   7B,W
0A08:  MOVWF  77
0A09:  MOVF   7C,W
0A0A:  MOVWF  78
0A0B:  MOVF   7D,W
0A0C:  MOVWF  79
0A0D:  MOVF   7E,W
0A0E:  MOVWF  7A
0A0F:  GOTO   2A1
....................            } else { 
0A10:  GOTO   21A
....................                // Still measuring a significant weight 
....................                return corrected_weight; 
0A11:  MOVF   7B,W
0A12:  MOVWF  77
0A13:  MOVF   7C,W
0A14:  MOVWF  78
0A15:  MOVF   7D,W
0A16:  MOVWF  79
0A17:  MOVF   7E,W
0A18:  MOVWF  7A
0A19:  GOTO   2A1
....................            } 
....................  
....................        case HX711_STATE_SETTLING_TO_ZERO: // Scale is trying to stabilize at 0g 
....................            // If weight remains near zero 
....................            if (fabs(corrected_weight) < HX711_NEAR_ZERO_THRESHOLD) { 
0A1A:  MOVF   7B,W
0A1B:  MOVWF  77
0A1C:  MOVF   7C,W
0A1D:  MOVWF  78
0A1E:  MOVF   7D,W
0A1F:  MOVWF  79
0A20:  MOVF   7E,W
0A21:  MOVWF  7A
0A22:  BCF    78.7
0A23:  MOVF   7A,W
0A24:  BSF    03.5
0A25:  MOVWF  23
0A26:  MOVF   79,W
0A27:  MOVWF  22
0A28:  MOVF   78,W
0A29:  MOVWF  21
0A2A:  MOVF   77,W
0A2B:  MOVWF  20
0A2C:  MOVF   23,W
0A2D:  MOVWF  27
0A2E:  MOVF   22,W
0A2F:  MOVWF  26
0A30:  MOVF   21,W
0A31:  MOVWF  25
0A32:  MOVF   20,W
0A33:  MOVWF  24
0A34:  CLRF   2B
0A35:  CLRF   2A
0A36:  MOVLW  20
0A37:  MOVWF  29
0A38:  MOVLW  82
0A39:  MOVWF  28
0A3A:  BCF    0A.3
0A3B:  BCF    03.5
0A3C:  CALL   277
0A3D:  BSF    0A.3
0A3E:  BTFSS  03.0
0A3F:  GOTO   25B
....................                zero_stability_counter++; 
0A40:  INCF   55,F
....................                // If stable near zero for long enough, perform an auto-tare and lock to zero 
....................                if (zero_stability_counter >= HX711_STABLE_ZERO_COUNT) { 
0A41:  MOVF   55,W
0A42:  SUBLW  1D
0A43:  BTFSC  03.0
0A44:  GOTO   255
....................                    OFFSET = readAverage(); // Auto-tare by updating offset 
0A45:  BCF    0A.3
0A46:  CALL   1FA
0A47:  BSF    0A.3
0A48:  MOVF   78,W
0A49:  MOVWF  4F
0A4A:  MOVF   77,W
0A4B:  MOVWF  4E
....................                    hx711_current_state = HX711_STATE_ZEROED; 
0A4C:  MOVLW  01
0A4D:  MOVWF  54
....................                    zero_stability_counter = 0; // Reset counter 
0A4E:  CLRF   55
....................                    return 0.0f; // Confirmed zero 
0A4F:  CLRF   77
0A50:  CLRF   78
0A51:  CLRF   79
0A52:  CLRF   7A
0A53:  GOTO   2A1
....................                } else { 
0A54:  GOTO   25A
....................                    // Still settling, display 0 to avoid flickering small values 
....................                    return 0.0f; 
0A55:  CLRF   77
0A56:  CLRF   78
0A57:  CLRF   79
0A58:  CLRF   7A
0A59:  GOTO   2A1
....................                } 
....................            } 
0A5A:  GOTO   29C
....................            // If a significant object is placed *during* settling, switch back to measuring 
....................            else if (fabs(corrected_weight) >= HX711_OBJECT_DETECTION_THRESHOLD) { 
0A5B:  MOVF   7B,W
0A5C:  MOVWF  77
0A5D:  MOVF   7C,W
0A5E:  MOVWF  78
0A5F:  MOVF   7D,W
0A60:  MOVWF  79
0A61:  MOVF   7E,W
0A62:  MOVWF  7A
0A63:  BCF    78.7
0A64:  MOVF   7A,W
0A65:  BSF    03.5
0A66:  MOVWF  23
0A67:  MOVF   79,W
0A68:  MOVWF  22
0A69:  MOVF   78,W
0A6A:  MOVWF  21
0A6B:  MOVF   77,W
0A6C:  MOVWF  20
0A6D:  CLRF   27
0A6E:  CLRF   26
0A6F:  MOVLW  20
0A70:  MOVWF  25
0A71:  MOVLW  83
0A72:  MOVWF  24
0A73:  MOVF   23,W
0A74:  MOVWF  2B
0A75:  MOVF   22,W
0A76:  MOVWF  2A
0A77:  MOVF   21,W
0A78:  MOVWF  29
0A79:  MOVF   20,W
0A7A:  MOVWF  28
0A7B:  BCF    0A.3
0A7C:  BCF    03.5
0A7D:  CALL   277
0A7E:  BSF    0A.3
0A7F:  BTFSC  03.0
0A80:  GOTO   283
0A81:  BTFSS  03.2
0A82:  GOTO   290
....................                hx711_current_state = HX711_STATE_MEASURING; 
0A83:  MOVLW  02
0A84:  MOVWF  54
....................                zero_stability_counter = 0; // Reset counter 
0A85:  CLRF   55
....................                return corrected_weight; 
0A86:  MOVF   7B,W
0A87:  MOVWF  77
0A88:  MOVF   7C,W
0A89:  MOVWF  78
0A8A:  MOVF   7D,W
0A8B:  MOVWF  79
0A8C:  MOVF   7E,W
0A8D:  MOVWF  7A
0A8E:  GOTO   2A1
....................            } 
0A8F:  GOTO   29C
....................            // If weight fluctuated out of near-zero but isn't a new object (e.g., minor drift/disturbance) 
....................            else { 
....................                zero_stability_counter = 0; // Reset settling counter as it's not stable near zero 
0A90:  CLRF   55
....................                hx711_current_state = HX711_STATE_MEASURING; // Go back to measuring mode 
0A91:  MOVLW  02
0A92:  MOVWF  54
....................                return corrected_weight; // Display the current reading 
0A93:  MOVF   7B,W
0A94:  MOVWF  77
0A95:  MOVF   7C,W
0A96:  MOVWF  78
0A97:  MOVF   7D,W
0A98:  MOVWF  79
0A99:  MOVF   7E,W
0A9A:  MOVWF  7A
0A9B:  GOTO   2A1
....................            } 
....................  
....................        default: // Should not happen 
....................            hx711_current_state = HX711_STATE_UNKNOWN; 
0A9C:  CLRF   54
....................            return 0.0f; 
0A9D:  CLRF   77
0A9E:  CLRF   78
0A9F:  CLRF   79
0AA0:  CLRF   7A
....................    } 
0AA1:  BSF    0A.3
0AA2:  BSF    0A.4
0AA3:  GOTO   2D7 (RETURN)
.................... } 
....................  
.................... // Hàm tare (d?t tr?ng lu?ng hi?n t?i v? 0) 
.................... void hx711_tare(int8 times) { 
....................    OFFSET = readAverage(); 
*
025F:  CALL   1FA
0260:  MOVF   78,W
0261:  MOVWF  4F
0262:  MOVF   77,W
0263:  MOVWF  4E
....................    hx711_current_state = HX711_STATE_ZEROED; // Set state to zeroed and locked 
0264:  MOVLW  01
0265:  MOVWF  54
....................    zero_stability_counter = 0; // Reset stability counter 
0266:  CLRF   55
0267:  RETURN
.................... } 
....................  
.................... // Hàm d?t h? s? scale th? công 
.................... void hx711_set_scale(double scale) { 
....................    SCALE = scale; 
.................... } 
....................  
.................... // Hàm hi?u chu?n HX711 v?i tr?ng lu?ng dã bi?t 
.................... void hx711_calibrate(float known_weight) { 
....................    if (known_weight <= 0) return; // Cannot calibrate with zero or negative weight 
*
03A3:  MOVF   70,W
03A4:  BSF    03.5
03A5:  MOVWF  27
03A6:  BCF    03.5
03A7:  MOVF   6F,W
03A8:  BSF    03.5
03A9:  MOVWF  26
03AA:  BCF    03.5
03AB:  MOVF   6E,W
03AC:  BSF    03.5
03AD:  MOVWF  25
03AE:  BCF    03.5
03AF:  MOVF   6D,W
03B0:  BSF    03.5
03B1:  MOVWF  24
03B2:  CLRF   2B
03B3:  CLRF   2A
03B4:  CLRF   29
03B5:  CLRF   28
03B6:  BCF    03.5
03B7:  CALL   277
03B8:  BTFSC  03.0
03B9:  GOTO   3BB
03BA:  BTFSC  03.2
03BB:  GOTO   41F
....................  
....................    // OFFSET should have been set by a previous call to hx711_tare() with an empty scale 
....................    long raw_value_with_weight = readAverage(); 
....................    long delta_raw = raw_value_with_weight - OFFSET; // Raw reading corresponding to known_weight 
03BC:  CALL   1FA
03BD:  MOVF   78,W
03BE:  MOVWF  72
03BF:  MOVF   77,W
03C0:  MOVWF  71
03C1:  MOVF   4E,W
03C2:  SUBWF  71,W
03C3:  MOVWF  73
03C4:  MOVF   72,W
03C5:  MOVWF  74
03C6:  MOVF   4F,W
03C7:  BTFSS  03.0
03C8:  INCFSZ 4F,W
03C9:  SUBWF  74,F
....................  
....................    if (delta_raw != 0) { // Avoid division by zero 
03CA:  MOVF   73,F
03CB:  BTFSS  03.2
03CC:  GOTO   3D0
03CD:  MOVF   74,F
03CE:  BTFSC  03.2
03CF:  GOTO   400
....................       SCALE = (double)delta_raw / known_weight; 
03D0:  MOVF   74,W
03D1:  BSF    03.5
03D2:  MOVWF  21
03D3:  MOVF   73,W
03D4:  MOVWF  20
03D5:  BCF    03.5
03D6:  CALL   2B8
03D7:  MOVF   7A,W
03D8:  MOVWF  7E
03D9:  MOVF   79,W
03DA:  MOVWF  7D
03DB:  MOVF   78,W
03DC:  MOVWF  7C
03DD:  MOVF   77,W
03DE:  MOVWF  7B
03DF:  MOVF   7A,W
03E0:  BSF    03.5
03E1:  MOVWF  23
03E2:  MOVF   79,W
03E3:  MOVWF  22
03E4:  MOVF   78,W
03E5:  MOVWF  21
03E6:  MOVF   77,W
03E7:  MOVWF  20
03E8:  MOVF   70,W
03E9:  MOVWF  27
03EA:  BCF    03.5
03EB:  MOVF   6F,W
03EC:  BSF    03.5
03ED:  MOVWF  26
03EE:  BCF    03.5
03EF:  MOVF   6E,W
03F0:  BSF    03.5
03F1:  MOVWF  25
03F2:  BCF    03.5
03F3:  MOVF   6D,W
03F4:  BSF    03.5
03F5:  MOVWF  24
03F6:  BCF    03.5
03F7:  CALL   2D7
03F8:  MOVF   7A,W
03F9:  MOVWF  53
03FA:  MOVF   79,W
03FB:  MOVWF  52
03FC:  MOVF   78,W
03FD:  MOVWF  51
03FE:  MOVF   77,W
03FF:  MOVWF  50
....................    } else { 
....................       // Error: delta_raw is zero, cannot calculate scale. 
....................       // Maybe the known_weight is too small or OFFSET is wrong. 
....................       // SCALE remains unchanged or could be set to an error indicator if needed. 
....................    } 
....................    // After calibration, the scale might not be in ZEROED state if weight is still on. 
....................    // The next call to hx711_get_units() will determine the state. 
....................    // Or, we could force it to MEASURING if known_weight > 0 
....................    if (known_weight > 0 && delta_raw != 0) { 
0400:  BSF    03.5
0401:  CLRF   27
0402:  CLRF   26
0403:  CLRF   25
0404:  CLRF   24
0405:  MOVF   70,W
0406:  MOVWF  2B
0407:  BCF    03.5
0408:  MOVF   6F,W
0409:  BSF    03.5
040A:  MOVWF  2A
040B:  BCF    03.5
040C:  MOVF   6E,W
040D:  BSF    03.5
040E:  MOVWF  29
040F:  BCF    03.5
0410:  MOVF   6D,W
0411:  BSF    03.5
0412:  MOVWF  28
0413:  BCF    03.5
0414:  CALL   277
0415:  BTFSS  03.0
0416:  GOTO   41F
0417:  MOVF   73,F
0418:  BTFSS  03.2
0419:  GOTO   41D
041A:  MOVF   74,F
041B:  BTFSC  03.2
041C:  GOTO   41F
....................        hx711_current_state = HX711_STATE_MEASURING; // Assume still measuring the calibration weight 
041D:  MOVLW  02
041E:  MOVWF  54
....................    } 
041F:  BSF    0A.3
0420:  BSF    0A.4
0421:  GOTO   283 (RETURN)
.................... } 
....................  
.................... #endif // HX711_H 
....................  
.................... #include "uart.h" 
.................... #ifndef UART_H 
.................... #define UART_H 
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
1850:  CLRF   56
1851:  CLRF   57
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, stream=UART_STREAM) 
....................  
.................... void uart_init() { 
*
0144:  BSF    0A.3
0145:  BSF    0A.4
0146:  GOTO   072 (RETURN)
....................    // UART du?c kh?i t?o b?i #use rs232 
.................... } 
....................  
.................... void uart_send_string(char *str) { 
....................    while (*str) { 
*
0F7C:  MOVF   63,W
0F7D:  MOVWF  7A
0F7E:  MOVF   62,W
0F7F:  MOVWF  04
0F80:  BCF    03.7
0F81:  BTFSC  7A.0
0F82:  BSF    03.7
0F83:  MOVF   00,F
0F84:  BTFSC  03.2
0F85:  GOTO   79C
....................       putc(*str, UART_STREAM); 
0F86:  MOVF   63,W
0F87:  MOVWF  7A
0F88:  MOVF   62,W
0F89:  MOVWF  04
0F8A:  BCF    03.7
0F8B:  BTFSC  63.0
0F8C:  BSF    03.7
0F8D:  MOVF   00,W
0F8E:  MOVWF  64
0F8F:  BCF    03.5
0F90:  BTFSS  0C.4
0F91:  GOTO   790
0F92:  MOVWF  19
....................       delay_us(200); // Tang d? tr? d? d?m b?o g?i hoàn ch?nh 
0F93:  MOVLW  85
0F94:  MOVWF  77
0F95:  DECFSZ 77,F
0F96:  GOTO   795
....................       str++; 
0F97:  BSF    03.5
0F98:  INCF   62,F
0F99:  BTFSC  03.2
0F9A:  INCF   63,F
0F9B:  GOTO   77C
....................    } 
.................... } 
....................  
.................... void uart_send_data(unsigned int8 temp, unsigned int8 hum, int32 hr_value, int32 spo2_value, int32 weight_grams) { 
*
0D48:  BSF    03.5
0D49:  BCF    60.0
0D4A:  CLRF   61
....................    char buffer[64]; // B? d?m d? l?n 
....................    int1 has_data = 0; 
....................    int pos = 0; 
....................  
....................    buffer[0] = '\0'; 
0D4B:  CLRF   20
....................  
....................    // Xây d?ng chu?i v?i m?t l?nh sprintf 
....................    if (temp != 0 || hum != 0 || hr_value != 0 || spo2_value != 0 || weight_grams != 0) { 
0D4C:  BCF    03.5
0D4D:  MOVF   6D,F
0D4E:  BTFSS  03.2
0D4F:  GOTO   577
0D50:  MOVF   6E,F
0D51:  BTFSS  03.2
0D52:  GOTO   577
0D53:  MOVF   6F,F
0D54:  BTFSS  03.2
0D55:  GOTO   577
0D56:  MOVF   70,F
0D57:  BTFSS  03.2
0D58:  GOTO   577
0D59:  MOVF   71,F
0D5A:  BTFSS  03.2
0D5B:  GOTO   577
0D5C:  MOVF   72,F
0D5D:  BTFSS  03.2
0D5E:  GOTO   577
0D5F:  MOVF   73,F
0D60:  BTFSS  03.2
0D61:  GOTO   577
0D62:  MOVF   74,F
0D63:  BTFSS  03.2
0D64:  GOTO   577
0D65:  MOVF   75,F
0D66:  BTFSS  03.2
0D67:  GOTO   577
0D68:  MOVF   76,F
0D69:  BTFSS  03.2
0D6A:  GOTO   577
0D6B:  MOVF   7B,F
0D6C:  BTFSS  03.2
0D6D:  GOTO   577
0D6E:  MOVF   7C,F
0D6F:  BTFSS  03.2
0D70:  GOTO   577
0D71:  MOVF   7D,F
0D72:  BTFSS  03.2
0D73:  GOTO   577
0D74:  MOVF   7E,F
0D75:  BTFSC  03.2
0D76:  GOTO   776
....................       if (temp != 0) { 
0D77:  MOVF   6D,F
0D78:  BTFSC  03.2
0D79:  GOTO   5B4
....................          pos += sprintf(buffer + pos, "T:%u ", (unsigned int)temp); 
0D7A:  MOVLW  A0
0D7B:  BSF    03.5
0D7C:  ADDWF  61,W
0D7D:  MOVWF  62
0D7E:  CLRF   63
0D7F:  BTFSC  03.0
0D80:  INCF   63,F
0D81:  MOVF   63,W
0D82:  BCF    03.5
0D83:  MOVWF  59
0D84:  BSF    03.5
0D85:  MOVF   62,W
0D86:  BCF    03.5
0D87:  MOVWF  58
0D88:  MOVLW  54
0D89:  BSF    03.6
0D8A:  MOVWF  10
0D8B:  BCF    0A.3
0D8C:  BCF    03.6
0D8D:  CALL   7EE
0D8E:  BSF    0A.3
0D8F:  MOVLW  3A
0D90:  BSF    03.6
0D91:  MOVWF  10
0D92:  BCF    0A.3
0D93:  BCF    03.6
0D94:  CALL   7EE
0D95:  BSF    0A.3
0D96:  MOVF   6D,W
0D97:  BSF    03.5
0D98:  MOVWF  64
0D99:  MOVLW  1B
0D9A:  MOVWF  65
0D9B:  BCF    03.5
0D9C:  CALL   433
0D9D:  MOVLW  20
0D9E:  BSF    03.6
0D9F:  MOVWF  10
0DA0:  BCF    0A.3
0DA1:  BCF    03.6
0DA2:  CALL   7EE
0DA3:  BSF    0A.3
0DA4:  BSF    03.5
0DA5:  MOVF   62,W
0DA6:  BCF    03.5
0DA7:  SUBWF  58,W
0DA8:  MOVWF  77
0DA9:  MOVF   59,W
0DAA:  MOVWF  7A
0DAB:  BSF    03.5
0DAC:  MOVF   63,W
0DAD:  BTFSS  03.0
0DAE:  INCFSZ 63,W
0DAF:  SUBWF  7A,F
0DB0:  MOVF   77,W
0DB1:  ADDWF  61,F
....................          has_data = 1; 
0DB2:  BSF    60.0
0DB3:  BCF    03.5
....................       } 
....................       if (hum != 0) { 
0DB4:  MOVF   6E,F
0DB5:  BTFSC  03.2
0DB6:  GOTO   5F1
....................          pos += sprintf(buffer + pos, "H:%u ", (unsigned int)hum); 
0DB7:  MOVLW  A0
0DB8:  BSF    03.5
0DB9:  ADDWF  61,W
0DBA:  MOVWF  62
0DBB:  CLRF   63
0DBC:  BTFSC  03.0
0DBD:  INCF   63,F
0DBE:  MOVF   63,W
0DBF:  BCF    03.5
0DC0:  MOVWF  59
0DC1:  BSF    03.5
0DC2:  MOVF   62,W
0DC3:  BCF    03.5
0DC4:  MOVWF  58
0DC5:  MOVLW  48
0DC6:  BSF    03.6
0DC7:  MOVWF  10
0DC8:  BCF    0A.3
0DC9:  BCF    03.6
0DCA:  CALL   7EE
0DCB:  BSF    0A.3
0DCC:  MOVLW  3A
0DCD:  BSF    03.6
0DCE:  MOVWF  10
0DCF:  BCF    0A.3
0DD0:  BCF    03.6
0DD1:  CALL   7EE
0DD2:  BSF    0A.3
0DD3:  MOVF   6E,W
0DD4:  BSF    03.5
0DD5:  MOVWF  64
0DD6:  MOVLW  1B
0DD7:  MOVWF  65
0DD8:  BCF    03.5
0DD9:  CALL   433
0DDA:  MOVLW  20
0DDB:  BSF    03.6
0DDC:  MOVWF  10
0DDD:  BCF    0A.3
0DDE:  BCF    03.6
0DDF:  CALL   7EE
0DE0:  BSF    0A.3
0DE1:  BSF    03.5
0DE2:  MOVF   62,W
0DE3:  BCF    03.5
0DE4:  SUBWF  58,W
0DE5:  MOVWF  77
0DE6:  MOVF   59,W
0DE7:  MOVWF  7A
0DE8:  BSF    03.5
0DE9:  MOVF   63,W
0DEA:  BTFSS  03.0
0DEB:  INCFSZ 63,W
0DEC:  SUBWF  7A,F
0DED:  MOVF   77,W
0DEE:  ADDWF  61,F
....................          has_data = 1; 
0DEF:  BSF    60.0
0DF0:  BCF    03.5
....................       } 
....................       if (hr_value != 0) { 
0DF1:  MOVF   6F,F
0DF2:  BTFSS  03.2
0DF3:  GOTO   5FD
0DF4:  MOVF   70,F
0DF5:  BTFSS  03.2
0DF6:  GOTO   5FD
0DF7:  MOVF   71,F
0DF8:  BTFSS  03.2
0DF9:  GOTO   5FD
0DFA:  MOVF   72,F
0DFB:  BTFSC  03.2
0DFC:  GOTO   646
....................          pos += sprintf(buffer + pos, "HR:%ld ", hr_value); 
0DFD:  MOVLW  A0
0DFE:  BSF    03.5
0DFF:  ADDWF  61,W
0E00:  MOVWF  62
0E01:  CLRF   63
0E02:  BTFSC  03.0
0E03:  INCF   63,F
0E04:  MOVF   63,W
0E05:  BCF    03.5
0E06:  MOVWF  59
0E07:  BSF    03.5
0E08:  MOVF   62,W
0E09:  BCF    03.5
0E0A:  MOVWF  58
0E0B:  MOVLW  48
0E0C:  BSF    03.6
0E0D:  MOVWF  10
0E0E:  BCF    0A.3
0E0F:  BCF    03.6
0E10:  CALL   7EE
0E11:  BSF    0A.3
0E12:  MOVLW  52
0E13:  BSF    03.6
0E14:  MOVWF  10
0E15:  BCF    0A.3
0E16:  BCF    03.6
0E17:  CALL   7EE
0E18:  BSF    0A.3
0E19:  MOVLW  3A
0E1A:  BSF    03.6
0E1B:  MOVWF  10
0E1C:  BCF    0A.3
0E1D:  BCF    03.6
0E1E:  CALL   7EE
0E1F:  BSF    0A.3
0E20:  MOVLW  41
0E21:  MOVWF  04
0E22:  MOVF   72,W
0E23:  BSF    03.5
0E24:  MOVWF  67
0E25:  MOVF   71,W
0E26:  MOVWF  66
0E27:  MOVF   70,W
0E28:  MOVWF  65
0E29:  BCF    03.5
0E2A:  MOVF   6F,W
0E2B:  BSF    03.5
0E2C:  MOVWF  64
0E2D:  BCF    03.5
0E2E:  CALL   47E
0E2F:  MOVLW  20
0E30:  BSF    03.6
0E31:  MOVWF  10
0E32:  BCF    0A.3
0E33:  BCF    03.6
0E34:  CALL   7EE
0E35:  BSF    0A.3
0E36:  BSF    03.5
0E37:  MOVF   62,W
0E38:  BCF    03.5
0E39:  SUBWF  58,W
0E3A:  MOVWF  77
0E3B:  MOVF   59,W
0E3C:  MOVWF  7A
0E3D:  BSF    03.5
0E3E:  MOVF   63,W
0E3F:  BTFSS  03.0
0E40:  INCFSZ 63,W
0E41:  SUBWF  7A,F
0E42:  MOVF   77,W
0E43:  ADDWF  61,F
....................          has_data = 1; 
0E44:  BSF    60.0
0E45:  BCF    03.5
....................       } 
....................       if (spo2_value != 0) { 
0E46:  MOVF   73,F
0E47:  BTFSS  03.2
0E48:  GOTO   652
0E49:  MOVF   74,F
0E4A:  BTFSS  03.2
0E4B:  GOTO   652
0E4C:  MOVF   75,F
0E4D:  BTFSS  03.2
0E4E:  GOTO   652
0E4F:  MOVF   76,F
0E50:  BTFSC  03.2
0E51:  GOTO   70B
....................          pos += sprintf(buffer + pos, "SPO2:%ld ", spo2_value); 
0E52:  MOVLW  A0
0E53:  BSF    03.5
0E54:  ADDWF  61,W
0E55:  MOVWF  62
0E56:  CLRF   63
0E57:  BTFSC  03.0
0E58:  INCF   63,F
0E59:  MOVF   63,W
0E5A:  BCF    03.5
0E5B:  MOVWF  59
0E5C:  BSF    03.5
0E5D:  MOVF   62,W
0E5E:  BCF    03.5
0E5F:  MOVWF  58
0E60:  MOVLW  04
0E61:  BSF    03.6
0E62:  MOVWF  0D
0E63:  MOVLW  00
0E64:  MOVWF  0F
0E65:  BCF    03.0
0E66:  MOVLW  05
0E67:  BSF    03.5
0E68:  BCF    03.6
0E69:  MOVWF  64
*
0EE8:  MOVLW  41
0EE9:  MOVWF  04
0EEA:  MOVF   76,W
0EEB:  MOVWF  67
0EEC:  MOVF   75,W
0EED:  MOVWF  66
0EEE:  MOVF   74,W
0EEF:  MOVWF  65
0EF0:  MOVF   73,W
0EF1:  MOVWF  64
0EF2:  BCF    03.5
0EF3:  CALL   47E
0EF4:  MOVLW  20
0EF5:  BSF    03.6
0EF6:  MOVWF  10
0EF7:  BCF    0A.3
0EF8:  BCF    03.6
0EF9:  CALL   7EE
0EFA:  BSF    0A.3
0EFB:  BSF    03.5
0EFC:  MOVF   62,W
0EFD:  BCF    03.5
0EFE:  SUBWF  58,W
0EFF:  MOVWF  77
0F00:  MOVF   59,W
0F01:  MOVWF  7A
0F02:  BSF    03.5
0F03:  MOVF   63,W
0F04:  BTFSS  03.0
0F05:  INCFSZ 63,W
0F06:  SUBWF  7A,F
0F07:  MOVF   77,W
0F08:  ADDWF  61,F
....................          has_data = 1; 
0F09:  BSF    60.0
0F0A:  BCF    03.5
....................       } 
....................       if (weight_grams != 0) { 
0F0B:  MOVF   7B,F
0F0C:  BTFSS  03.2
0F0D:  GOTO   717
0F0E:  MOVF   7C,F
0F0F:  BTFSS  03.2
0F10:  GOTO   717
0F11:  MOVF   7D,F
0F12:  BTFSS  03.2
0F13:  GOTO   717
0F14:  MOVF   7E,F
0F15:  BTFSC  03.2
0F16:  GOTO   750
....................          pos += sprintf(buffer + pos, "W:%ld", weight_grams); 
0F17:  MOVLW  A0
0F18:  BSF    03.5
0F19:  ADDWF  61,W
0F1A:  MOVWF  62
0F1B:  CLRF   63
0F1C:  BTFSC  03.0
0F1D:  INCF   63,F
0F1E:  MOVF   63,W
0F1F:  BCF    03.5
0F20:  MOVWF  59
0F21:  BSF    03.5
0F22:  MOVF   62,W
0F23:  BCF    03.5
0F24:  MOVWF  58
0F25:  MOVLW  57
0F26:  BSF    03.6
0F27:  MOVWF  10
0F28:  BCF    0A.3
0F29:  BCF    03.6
0F2A:  CALL   7EE
0F2B:  BSF    0A.3
0F2C:  MOVLW  3A
0F2D:  BSF    03.6
0F2E:  MOVWF  10
0F2F:  BCF    0A.3
0F30:  BCF    03.6
0F31:  CALL   7EE
0F32:  BSF    0A.3
0F33:  MOVLW  41
0F34:  MOVWF  04
0F35:  MOVF   7E,W
0F36:  BSF    03.5
0F37:  MOVWF  67
0F38:  MOVF   7D,W
0F39:  MOVWF  66
0F3A:  MOVF   7C,W
0F3B:  MOVWF  65
0F3C:  MOVF   7B,W
0F3D:  MOVWF  64
0F3E:  BCF    03.5
0F3F:  CALL   47E
0F40:  BSF    03.5
0F41:  MOVF   62,W
0F42:  BCF    03.5
0F43:  SUBWF  58,W
0F44:  MOVWF  77
0F45:  MOVF   59,W
0F46:  MOVWF  7A
0F47:  BSF    03.5
0F48:  MOVF   63,W
0F49:  BTFSS  03.0
0F4A:  INCFSZ 63,W
0F4B:  SUBWF  7A,F
0F4C:  MOVF   77,W
0F4D:  ADDWF  61,F
....................          has_data = 1; 
0F4E:  BSF    60.0
0F4F:  BCF    03.5
....................       } 
....................       if (has_data) { 
0F50:  BSF    03.5
0F51:  BTFSS  60.0
0F52:  GOTO   775
....................          pos += sprintf(buffer + pos, "\n"); 
0F53:  MOVLW  A0
0F54:  ADDWF  61,W
0F55:  MOVWF  62
0F56:  CLRF   63
0F57:  BTFSC  03.0
0F58:  INCF   63,F
0F59:  MOVF   63,W
0F5A:  BCF    03.5
0F5B:  MOVWF  59
0F5C:  BSF    03.5
0F5D:  MOVF   62,W
0F5E:  BCF    03.5
0F5F:  MOVWF  58
0F60:  MOVLW  0A
0F61:  BSF    03.6
0F62:  MOVWF  10
0F63:  BCF    0A.3
0F64:  BCF    03.6
0F65:  CALL   7EE
0F66:  BSF    0A.3
0F67:  BSF    03.5
0F68:  MOVF   62,W
0F69:  BCF    03.5
0F6A:  SUBWF  58,W
0F6B:  MOVWF  77
0F6C:  MOVF   59,W
0F6D:  MOVWF  7A
0F6E:  BSF    03.5
0F6F:  MOVF   63,W
0F70:  BTFSS  03.0
0F71:  INCFSZ 63,W
0F72:  SUBWF  7A,F
0F73:  MOVF   77,W
0F74:  ADDWF  61,F
0F75:  BCF    03.5
....................       } 
....................    } 
....................  
....................    // G?i chu?i n?u có d? li?u 
....................    if (has_data) { 
0F76:  BSF    03.5
0F77:  BTFSS  60.0
0F78:  GOTO   79C
....................       uart_send_string(buffer); 
0F79:  CLRF   63
0F7A:  MOVLW  A0
0F7B:  MOVWF  62
....................    } 
*
0F9C:  BCF    03.5
0F9D:  BSF    0A.3
0F9E:  BSF    0A.4
0F9F:  GOTO   3BE (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... // --- Timing Interval Constants (in number of 5ms ticks) --- 
.................... #define DHT11_INTERVAL_TICKS        100 // 100 * 5ms = 500ms 
.................... // #define HX711_INTERVAL_TICKS        20  // OLD: 20 * 5ms = 100ms 
.................... #define HX711_INTERVAL_TICKS        50  // NEW: 50 * 5ms = 250ms (Try this, or 40, 60) 
.................... #define DISPLAY_UART_INTERVAL_TICKS 50  // 50 * 5ms = 250ms 
....................  
.................... // --- Other Constants --- 
.................... #define WEIGHT_DEADBAND             2  // Ngu?ng ch?t cho cân n?ng (gram) 
....................  
.................... // Kh?i lu?ng v?t m?u dã bi?t d? hi?u chu?n (b?n c?n d?t v?t này lên cân) 
.................... // Ð?T GIÁ TR? NÀY CHO TR?NG LU?NG MÀ B?N S? DÙNG Ð? HI?U CHU?N 
.................... #define KNOWN_WEIGHT_FOR_CALIBRATION 31.0 // Ví d?: 100.0 gram (d?m b?o chính xác) 
....................  
.................... // Bi?n c? d? ki?m soát vi?c hi?u chu?n ch? ch?y m?t l?n 
.................... int1 calibrate_done = FALSE; 
....................  
.................... // Display number on LCD (support 2, 3, or 5 digits) 
.................... void display_number(int32 num, int8 pos, int8 digits) { 
....................    if (num > 99 && digits == 2) num = 99; // Limit to 2 digits for T, H 
*
1000:  MOVF   70,F
1001:  BTFSS  03.2
1002:  GOTO   00D
1003:  MOVF   6F,F
1004:  BTFSS  03.2
1005:  GOTO   00D
1006:  MOVF   6E,F
1007:  BTFSS  03.2
1008:  GOTO   00D
1009:  MOVF   6D,W
100A:  SUBLW  63
100B:  BTFSC  03.0
100C:  GOTO   016
100D:  MOVF   72,W
100E:  SUBLW  02
100F:  BTFSS  03.2
1010:  GOTO   016
1011:  CLRF   70
1012:  CLRF   6F
1013:  CLRF   6E
1014:  MOVLW  63
1015:  MOVWF  6D
....................    if (num > 999 && digits == 3) num = 999; // Limit to 3 digits for HR, SpO2 
1016:  MOVF   70,F
1017:  BTFSS  03.2
1018:  GOTO   027
1019:  MOVF   6F,F
101A:  BTFSS  03.2
101B:  GOTO   027
101C:  MOVF   6E,W
101D:  SUBLW  02
101E:  BTFSC  03.0
101F:  GOTO   031
1020:  XORLW  FF
1021:  BTFSS  03.2
1022:  GOTO   027
1023:  MOVF   6D,W
1024:  SUBLW  E7
1025:  BTFSC  03.0
1026:  GOTO   031
1027:  MOVF   72,W
1028:  SUBLW  03
1029:  BTFSS  03.2
102A:  GOTO   031
102B:  CLRF   70
102C:  CLRF   6F
102D:  MOVLW  03
102E:  MOVWF  6E
102F:  MOVLW  E7
1030:  MOVWF  6D
....................    if (num > 99999 && digits == 5) num = 99999; // Limit to 5 digits for weight 
1031:  MOVF   70,F
1032:  BTFSS  03.2
1033:  GOTO   046
1034:  MOVF   6F,W
1035:  SUBLW  00
1036:  BTFSC  03.0
1037:  GOTO   051
1038:  XORLW  FF
1039:  BTFSS  03.2
103A:  GOTO   046
103B:  MOVF   6E,W
103C:  SUBLW  85
103D:  BTFSC  03.0
103E:  GOTO   051
103F:  XORLW  FF
1040:  BTFSS  03.2
1041:  GOTO   046
1042:  MOVF   6D,W
1043:  SUBLW  9F
1044:  BTFSC  03.0
1045:  GOTO   051
1046:  MOVF   72,W
1047:  SUBLW  05
1048:  BTFSS  03.2
1049:  GOTO   051
104A:  CLRF   70
104B:  MOVLW  01
104C:  MOVWF  6F
104D:  MOVLW  86
104E:  MOVWF  6E
104F:  MOVLW  9F
1050:  MOVWF  6D
....................  
....................    LCD_SetPosition(pos); 
1051:  MOVF   71,W
1052:  BSF    03.5
1053:  MOVWF  20
1054:  BCF    0A.4
1055:  BCF    03.5
1056:  CALL   268
1057:  BSF    0A.4
....................    if (digits == 2) { 
1058:  MOVF   72,W
1059:  SUBLW  02
105A:  BTFSS  03.2
105B:  GOTO   0CC
....................       LCD_PutChar(num / 10 + '0'); // Tens digit 
105C:  BCF    03.1
105D:  MOVF   70,W
105E:  BSF    03.6
105F:  MOVWF  13
1060:  BCF    03.6
1061:  MOVF   6F,W
1062:  BSF    03.6
1063:  MOVWF  12
1064:  BCF    03.6
1065:  MOVF   6E,W
1066:  BSF    03.6
1067:  MOVWF  11
1068:  BCF    03.6
1069:  MOVF   6D,W
106A:  BSF    03.6
106B:  MOVWF  10
106C:  CLRF   17
106D:  CLRF   16
106E:  CLRF   15
106F:  MOVLW  0A
1070:  MOVWF  14
1071:  BCF    0A.4
1072:  BCF    03.6
1073:  CALL   1A9
1074:  BSF    0A.4
1075:  MOVF   7A,W
1076:  BSF    03.5
1077:  MOVWF  23
1078:  MOVF   79,W
1079:  MOVWF  22
107A:  MOVF   78,W
107B:  MOVWF  21
107C:  MOVF   77,W
107D:  MOVWF  20
107E:  MOVLW  30
107F:  ADDWF  20,F
1080:  MOVLW  00
1081:  BTFSC  03.0
1082:  MOVLW  01
1083:  ADDWF  21,F
1084:  MOVLW  00
1085:  BTFSC  03.0
1086:  MOVLW  01
1087:  ADDWF  22,F
1088:  MOVLW  00
1089:  BTFSC  03.0
108A:  MOVLW  01
108B:  ADDWF  23,F
108C:  MOVF   20,W
108D:  MOVWF  2A
108E:  BCF    0A.4
108F:  BCF    03.5
1090:  CALL   26F
1091:  BSF    0A.4
....................       LCD_PutChar(num % 10 + '0'); // Units digit 
1092:  BSF    03.1
1093:  MOVLW  A0
1094:  MOVWF  04
1095:  BCF    03.7
1096:  MOVF   70,W
1097:  BSF    03.6
1098:  MOVWF  13
1099:  BCF    03.6
109A:  MOVF   6F,W
109B:  BSF    03.6
109C:  MOVWF  12
109D:  BCF    03.6
109E:  MOVF   6E,W
109F:  BSF    03.6
10A0:  MOVWF  11
10A1:  BCF    03.6
10A2:  MOVF   6D,W
10A3:  BSF    03.6
10A4:  MOVWF  10
10A5:  CLRF   17
10A6:  CLRF   16
10A7:  CLRF   15
10A8:  MOVLW  0A
10A9:  MOVWF  14
10AA:  BCF    0A.4
10AB:  BCF    03.6
10AC:  CALL   1A9
10AD:  BSF    0A.4
10AE:  BSF    03.5
10AF:  MOVF   23,W
10B0:  MOVWF  27
10B1:  MOVF   22,W
10B2:  MOVWF  26
10B3:  MOVF   21,W
10B4:  MOVWF  25
10B5:  MOVF   20,W
10B6:  MOVWF  24
10B7:  MOVLW  30
10B8:  ADDWF  24,F
10B9:  MOVLW  00
10BA:  BTFSC  03.0
10BB:  MOVLW  01
10BC:  ADDWF  25,F
10BD:  MOVLW  00
10BE:  BTFSC  03.0
10BF:  MOVLW  01
10C0:  ADDWF  26,F
10C1:  MOVLW  00
10C2:  BTFSC  03.0
10C3:  MOVLW  01
10C4:  ADDWF  27,F
10C5:  MOVF   24,W
10C6:  MOVWF  2A
10C7:  BCF    0A.4
10C8:  BCF    03.5
10C9:  CALL   26F
10CA:  BSF    0A.4
....................    } else if (digits == 3) { 
10CB:  GOTO   767
10CC:  MOVF   72,W
10CD:  SUBLW  03
10CE:  BTFSS  03.2
10CF:  GOTO   26D
....................       if (num >= 100) { 
10D0:  MOVF   70,F
10D1:  BTFSS  03.2
10D2:  GOTO   0DD
10D3:  MOVF   6F,F
10D4:  BTFSS  03.2
10D5:  GOTO   0DD
10D6:  MOVF   6E,F
10D7:  BTFSS  03.2
10D8:  GOTO   0DD
10D9:  MOVF   6D,W
10DA:  SUBLW  63
10DB:  BTFSC  03.0
10DC:  GOTO   1BA
....................          LCD_PutChar(num / 100 + '0'); 
10DD:  BCF    03.1
10DE:  MOVF   70,W
10DF:  BSF    03.6
10E0:  MOVWF  13
10E1:  BCF    03.6
10E2:  MOVF   6F,W
10E3:  BSF    03.6
10E4:  MOVWF  12
10E5:  BCF    03.6
10E6:  MOVF   6E,W
10E7:  BSF    03.6
10E8:  MOVWF  11
10E9:  BCF    03.6
10EA:  MOVF   6D,W
10EB:  BSF    03.6
10EC:  MOVWF  10
10ED:  CLRF   17
10EE:  CLRF   16
10EF:  CLRF   15
10F0:  MOVLW  64
10F1:  MOVWF  14
10F2:  BCF    0A.4
10F3:  BCF    03.6
10F4:  CALL   1A9
10F5:  BSF    0A.4
10F6:  MOVF   7A,W
10F7:  BSF    03.5
10F8:  MOVWF  23
10F9:  MOVF   79,W
10FA:  MOVWF  22
10FB:  MOVF   78,W
10FC:  MOVWF  21
10FD:  MOVF   77,W
10FE:  MOVWF  20
10FF:  MOVLW  30
1100:  ADDWF  20,F
1101:  MOVLW  00
1102:  BTFSC  03.0
1103:  MOVLW  01
1104:  ADDWF  21,F
1105:  MOVLW  00
1106:  BTFSC  03.0
1107:  MOVLW  01
1108:  ADDWF  22,F
1109:  MOVLW  00
110A:  BTFSC  03.0
110B:  MOVLW  01
110C:  ADDWF  23,F
110D:  MOVF   20,W
110E:  MOVWF  2A
110F:  BCF    0A.4
1110:  BCF    03.5
1111:  CALL   26F
1112:  BSF    0A.4
....................          LCD_PutChar((num % 100) / 10 + '0'); 
1113:  BSF    03.1
1114:  MOVLW  A0
1115:  MOVWF  04
1116:  BCF    03.7
1117:  MOVF   70,W
1118:  BSF    03.6
1119:  MOVWF  13
111A:  BCF    03.6
111B:  MOVF   6F,W
111C:  BSF    03.6
111D:  MOVWF  12
111E:  BCF    03.6
111F:  MOVF   6E,W
1120:  BSF    03.6
1121:  MOVWF  11
1122:  BCF    03.6
1123:  MOVF   6D,W
1124:  BSF    03.6
1125:  MOVWF  10
1126:  CLRF   17
1127:  CLRF   16
1128:  CLRF   15
1129:  MOVLW  64
112A:  MOVWF  14
112B:  BCF    0A.4
112C:  BCF    03.6
112D:  CALL   1A9
112E:  BSF    0A.4
112F:  BSF    03.5
1130:  MOVF   23,W
1131:  MOVWF  27
1132:  MOVF   22,W
1133:  MOVWF  26
1134:  MOVF   21,W
1135:  MOVWF  25
1136:  MOVF   20,W
1137:  MOVWF  24
1138:  CLRF   29
1139:  MOVF   04,W
113A:  MOVWF  28
113B:  BCF    29.0
113C:  BTFSC  03.7
113D:  BSF    29.0
113E:  BCF    03.1
113F:  MOVF   27,W
1140:  BCF    03.5
1141:  BSF    03.6
1142:  MOVWF  13
1143:  BSF    03.5
1144:  BCF    03.6
1145:  MOVF   26,W
1146:  BCF    03.5
1147:  BSF    03.6
1148:  MOVWF  12
1149:  BSF    03.5
114A:  BCF    03.6
114B:  MOVF   25,W
114C:  BCF    03.5
114D:  BSF    03.6
114E:  MOVWF  11
114F:  BSF    03.5
1150:  BCF    03.6
1151:  MOVF   24,W
1152:  BCF    03.5
1153:  BSF    03.6
1154:  MOVWF  10
1155:  CLRF   17
1156:  CLRF   16
1157:  CLRF   15
1158:  MOVLW  0A
1159:  MOVWF  14
115A:  BCF    0A.4
115B:  BCF    03.6
115C:  CALL   1A9
115D:  BSF    0A.4
115E:  BSF    03.5
115F:  MOVF   28,W
1160:  MOVWF  04
1161:  BCF    03.7
1162:  BTFSC  29.0
1163:  BSF    03.7
1164:  MOVF   7A,W
1165:  MOVWF  27
1166:  MOVF   79,W
1167:  MOVWF  26
1168:  MOVF   78,W
1169:  MOVWF  25
116A:  MOVF   77,W
116B:  MOVWF  24
116C:  MOVLW  30
116D:  ADDWF  24,F
116E:  MOVLW  00
116F:  BTFSC  03.0
1170:  MOVLW  01
1171:  ADDWF  25,F
1172:  MOVLW  00
1173:  BTFSC  03.0
1174:  MOVLW  01
1175:  ADDWF  26,F
1176:  MOVLW  00
1177:  BTFSC  03.0
1178:  MOVLW  01
1179:  ADDWF  27,F
117A:  MOVF   24,W
117B:  MOVWF  2A
117C:  BCF    0A.4
117D:  BCF    03.5
117E:  CALL   26F
117F:  BSF    0A.4
....................          LCD_PutChar(num % 10 + '0'); 
1180:  BSF    03.1
1181:  MOVLW  A0
1182:  MOVWF  04
1183:  BCF    03.7
1184:  MOVF   70,W
1185:  BSF    03.6
1186:  MOVWF  13
1187:  BCF    03.6
1188:  MOVF   6F,W
1189:  BSF    03.6
118A:  MOVWF  12
118B:  BCF    03.6
118C:  MOVF   6E,W
118D:  BSF    03.6
118E:  MOVWF  11
118F:  BCF    03.6
1190:  MOVF   6D,W
1191:  BSF    03.6
1192:  MOVWF  10
1193:  CLRF   17
1194:  CLRF   16
1195:  CLRF   15
1196:  MOVLW  0A
1197:  MOVWF  14
1198:  BCF    0A.4
1199:  BCF    03.6
119A:  CALL   1A9
119B:  BSF    0A.4
119C:  BSF    03.5
119D:  MOVF   23,W
119E:  MOVWF  27
119F:  MOVF   22,W
11A0:  MOVWF  26
11A1:  MOVF   21,W
11A2:  MOVWF  25
11A3:  MOVF   20,W
11A4:  MOVWF  24
11A5:  MOVLW  30
11A6:  ADDWF  24,F
11A7:  MOVLW  00
11A8:  BTFSC  03.0
11A9:  MOVLW  01
11AA:  ADDWF  25,F
11AB:  MOVLW  00
11AC:  BTFSC  03.0
11AD:  MOVLW  01
11AE:  ADDWF  26,F
11AF:  MOVLW  00
11B0:  BTFSC  03.0
11B1:  MOVLW  01
11B2:  ADDWF  27,F
11B3:  MOVF   24,W
11B4:  MOVWF  2A
11B5:  BCF    0A.4
11B6:  BCF    03.5
11B7:  CALL   26F
11B8:  BSF    0A.4
....................       } else if (num >= 10) { 
11B9:  GOTO   26C
11BA:  MOVF   70,F
11BB:  BTFSS  03.2
11BC:  GOTO   1C7
11BD:  MOVF   6F,F
11BE:  BTFSS  03.2
11BF:  GOTO   1C7
11C0:  MOVF   6E,F
11C1:  BTFSS  03.2
11C2:  GOTO   1C7
11C3:  MOVF   6D,W
11C4:  SUBLW  09
11C5:  BTFSC  03.0
11C6:  GOTO   23E
....................          LCD_PutChar(' '); 
11C7:  MOVLW  20
11C8:  BSF    03.5
11C9:  MOVWF  2A
11CA:  BCF    0A.4
11CB:  BCF    03.5
11CC:  CALL   26F
11CD:  BSF    0A.4
....................          LCD_PutChar(num / 10 + '0'); 
11CE:  BCF    03.1
11CF:  MOVF   70,W
11D0:  BSF    03.6
11D1:  MOVWF  13
11D2:  BCF    03.6
11D3:  MOVF   6F,W
11D4:  BSF    03.6
11D5:  MOVWF  12
11D6:  BCF    03.6
11D7:  MOVF   6E,W
11D8:  BSF    03.6
11D9:  MOVWF  11
11DA:  BCF    03.6
11DB:  MOVF   6D,W
11DC:  BSF    03.6
11DD:  MOVWF  10
11DE:  CLRF   17
11DF:  CLRF   16
11E0:  CLRF   15
11E1:  MOVLW  0A
11E2:  MOVWF  14
11E3:  BCF    0A.4
11E4:  BCF    03.6
11E5:  CALL   1A9
11E6:  BSF    0A.4
11E7:  MOVF   7A,W
11E8:  BSF    03.5
11E9:  MOVWF  23
11EA:  MOVF   79,W
11EB:  MOVWF  22
11EC:  MOVF   78,W
11ED:  MOVWF  21
11EE:  MOVF   77,W
11EF:  MOVWF  20
11F0:  MOVLW  30
11F1:  ADDWF  20,F
11F2:  MOVLW  00
11F3:  BTFSC  03.0
11F4:  MOVLW  01
11F5:  ADDWF  21,F
11F6:  MOVLW  00
11F7:  BTFSC  03.0
11F8:  MOVLW  01
11F9:  ADDWF  22,F
11FA:  MOVLW  00
11FB:  BTFSC  03.0
11FC:  MOVLW  01
11FD:  ADDWF  23,F
11FE:  MOVF   20,W
11FF:  MOVWF  2A
1200:  BCF    0A.4
1201:  BCF    03.5
1202:  CALL   26F
1203:  BSF    0A.4
....................          LCD_PutChar(num % 10 + '0'); 
1204:  BSF    03.1
1205:  MOVLW  A0
1206:  MOVWF  04
1207:  BCF    03.7
1208:  MOVF   70,W
1209:  BSF    03.6
120A:  MOVWF  13
120B:  BCF    03.6
120C:  MOVF   6F,W
120D:  BSF    03.6
120E:  MOVWF  12
120F:  BCF    03.6
1210:  MOVF   6E,W
1211:  BSF    03.6
1212:  MOVWF  11
1213:  BCF    03.6
1214:  MOVF   6D,W
1215:  BSF    03.6
1216:  MOVWF  10
1217:  CLRF   17
1218:  CLRF   16
1219:  CLRF   15
121A:  MOVLW  0A
121B:  MOVWF  14
121C:  BCF    0A.4
121D:  BCF    03.6
121E:  CALL   1A9
121F:  BSF    0A.4
1220:  BSF    03.5
1221:  MOVF   23,W
1222:  MOVWF  27
1223:  MOVF   22,W
1224:  MOVWF  26
1225:  MOVF   21,W
1226:  MOVWF  25
1227:  MOVF   20,W
1228:  MOVWF  24
1229:  MOVLW  30
122A:  ADDWF  24,F
122B:  MOVLW  00
122C:  BTFSC  03.0
122D:  MOVLW  01
122E:  ADDWF  25,F
122F:  MOVLW  00
1230:  BTFSC  03.0
1231:  MOVLW  01
1232:  ADDWF  26,F
1233:  MOVLW  00
1234:  BTFSC  03.0
1235:  MOVLW  01
1236:  ADDWF  27,F
1237:  MOVF   24,W
1238:  MOVWF  2A
1239:  BCF    0A.4
123A:  BCF    03.5
123B:  CALL   26F
123C:  BSF    0A.4
....................       } else { 
123D:  GOTO   26C
....................          LCD_PutChar(' '); 
123E:  MOVLW  20
123F:  BSF    03.5
1240:  MOVWF  2A
1241:  BCF    0A.4
1242:  BCF    03.5
1243:  CALL   26F
1244:  BSF    0A.4
....................          LCD_PutChar(' '); 
1245:  MOVLW  20
1246:  BSF    03.5
1247:  MOVWF  2A
1248:  BCF    0A.4
1249:  BCF    03.5
124A:  CALL   26F
124B:  BSF    0A.4
....................          LCD_PutChar(num + '0'); 
124C:  MOVLW  30
124D:  ADDWF  6D,W
124E:  BSF    03.5
124F:  MOVWF  20
1250:  BCF    03.5
1251:  MOVF   6E,W
1252:  BSF    03.5
1253:  MOVWF  21
1254:  MOVLW  00
1255:  BTFSC  03.0
1256:  MOVLW  01
1257:  ADDWF  21,F
1258:  BCF    03.5
1259:  MOVF   6F,W
125A:  BSF    03.5
125B:  MOVWF  22
125C:  MOVLW  00
125D:  BTFSC  03.0
125E:  MOVLW  01
125F:  ADDWF  22,F
1260:  MOVF   70,W
1261:  MOVWF  23
1262:  MOVLW  00
1263:  BTFSC  03.0
1264:  MOVLW  01
1265:  ADDWF  23,F
1266:  MOVF   20,W
1267:  MOVWF  2A
1268:  BCF    0A.4
1269:  BCF    03.5
126A:  CALL   26F
126B:  BSF    0A.4
....................       } 
....................    } else if (digits == 5) { 
126C:  GOTO   767
126D:  MOVF   72,W
126E:  SUBLW  05
126F:  BTFSS  03.2
1270:  GOTO   767
....................       if (num >= 10000) { 
1271:  MOVF   70,F
1272:  BTFSS  03.2
1273:  GOTO   282
1274:  MOVF   6F,F
1275:  BTFSS  03.2
1276:  GOTO   282
1277:  MOVF   6E,W
1278:  SUBLW  26
1279:  BTFSC  03.0
127A:  GOTO   43D
127B:  XORLW  FF
127C:  BTFSS  03.2
127D:  GOTO   282
127E:  MOVF   6D,W
127F:  SUBLW  0F
1280:  BTFSC  03.0
1281:  GOTO   43D
....................          LCD_PutChar(num / 10000 + '0'); 
1282:  BCF    03.1
1283:  MOVF   70,W
1284:  BSF    03.6
1285:  MOVWF  13
1286:  BCF    03.6
1287:  MOVF   6F,W
1288:  BSF    03.6
1289:  MOVWF  12
128A:  BCF    03.6
128B:  MOVF   6E,W
128C:  BSF    03.6
128D:  MOVWF  11
128E:  BCF    03.6
128F:  MOVF   6D,W
1290:  BSF    03.6
1291:  MOVWF  10
1292:  CLRF   17
1293:  CLRF   16
1294:  MOVLW  27
1295:  MOVWF  15
1296:  MOVLW  10
1297:  MOVWF  14
1298:  BCF    0A.4
1299:  BCF    03.6
129A:  CALL   1A9
129B:  BSF    0A.4
129C:  MOVF   7A,W
129D:  BSF    03.5
129E:  MOVWF  23
129F:  MOVF   79,W
12A0:  MOVWF  22
12A1:  MOVF   78,W
12A2:  MOVWF  21
12A3:  MOVF   77,W
12A4:  MOVWF  20
12A5:  MOVLW  30
12A6:  ADDWF  20,F
12A7:  MOVLW  00
12A8:  BTFSC  03.0
12A9:  MOVLW  01
12AA:  ADDWF  21,F
12AB:  MOVLW  00
12AC:  BTFSC  03.0
12AD:  MOVLW  01
12AE:  ADDWF  22,F
12AF:  MOVLW  00
12B0:  BTFSC  03.0
12B1:  MOVLW  01
12B2:  ADDWF  23,F
12B3:  MOVF   20,W
12B4:  MOVWF  2A
12B5:  BCF    0A.4
12B6:  BCF    03.5
12B7:  CALL   26F
12B8:  BSF    0A.4
....................          LCD_PutChar((num % 10000) / 1000 + '0'); 
12B9:  BSF    03.1
12BA:  MOVLW  A0
12BB:  MOVWF  04
12BC:  BCF    03.7
12BD:  MOVF   70,W
12BE:  BSF    03.6
12BF:  MOVWF  13
12C0:  BCF    03.6
12C1:  MOVF   6F,W
12C2:  BSF    03.6
12C3:  MOVWF  12
12C4:  BCF    03.6
12C5:  MOVF   6E,W
12C6:  BSF    03.6
12C7:  MOVWF  11
12C8:  BCF    03.6
12C9:  MOVF   6D,W
12CA:  BSF    03.6
12CB:  MOVWF  10
12CC:  CLRF   17
12CD:  CLRF   16
12CE:  MOVLW  27
12CF:  MOVWF  15
12D0:  MOVLW  10
12D1:  MOVWF  14
12D2:  BCF    0A.4
12D3:  BCF    03.6
12D4:  CALL   1A9
12D5:  BSF    0A.4
12D6:  BSF    03.5
12D7:  MOVF   23,W
12D8:  MOVWF  27
12D9:  MOVF   22,W
12DA:  MOVWF  26
12DB:  MOVF   21,W
12DC:  MOVWF  25
12DD:  MOVF   20,W
12DE:  MOVWF  24
12DF:  CLRF   29
12E0:  MOVF   04,W
12E1:  MOVWF  28
12E2:  BCF    29.0
12E3:  BTFSC  03.7
12E4:  BSF    29.0
12E5:  BCF    03.1
12E6:  MOVF   27,W
12E7:  BCF    03.5
12E8:  BSF    03.6
12E9:  MOVWF  13
12EA:  BSF    03.5
12EB:  BCF    03.6
12EC:  MOVF   26,W
12ED:  BCF    03.5
12EE:  BSF    03.6
12EF:  MOVWF  12
12F0:  BSF    03.5
12F1:  BCF    03.6
12F2:  MOVF   25,W
12F3:  BCF    03.5
12F4:  BSF    03.6
12F5:  MOVWF  11
12F6:  BSF    03.5
12F7:  BCF    03.6
12F8:  MOVF   24,W
12F9:  BCF    03.5
12FA:  BSF    03.6
12FB:  MOVWF  10
12FC:  CLRF   17
12FD:  CLRF   16
12FE:  MOVLW  03
12FF:  MOVWF  15
1300:  MOVLW  E8
1301:  MOVWF  14
1302:  BCF    0A.4
1303:  BCF    03.6
1304:  CALL   1A9
1305:  BSF    0A.4
1306:  BSF    03.5
1307:  MOVF   28,W
1308:  MOVWF  04
1309:  BCF    03.7
130A:  BTFSC  29.0
130B:  BSF    03.7
130C:  MOVF   7A,W
130D:  MOVWF  27
130E:  MOVF   79,W
130F:  MOVWF  26
1310:  MOVF   78,W
1311:  MOVWF  25
1312:  MOVF   77,W
1313:  MOVWF  24
1314:  MOVLW  30
1315:  ADDWF  24,F
1316:  MOVLW  00
1317:  BTFSC  03.0
1318:  MOVLW  01
1319:  ADDWF  25,F
131A:  MOVLW  00
131B:  BTFSC  03.0
131C:  MOVLW  01
131D:  ADDWF  26,F
131E:  MOVLW  00
131F:  BTFSC  03.0
1320:  MOVLW  01
1321:  ADDWF  27,F
1322:  MOVF   24,W
1323:  MOVWF  2A
1324:  BCF    0A.4
1325:  BCF    03.5
1326:  CALL   26F
1327:  BSF    0A.4
....................          LCD_PutChar((num % 1000) / 100 + '0'); 
1328:  BSF    03.1
1329:  MOVLW  A0
132A:  MOVWF  04
132B:  BCF    03.7
132C:  MOVF   70,W
132D:  BSF    03.6
132E:  MOVWF  13
132F:  BCF    03.6
1330:  MOVF   6F,W
1331:  BSF    03.6
1332:  MOVWF  12
1333:  BCF    03.6
1334:  MOVF   6E,W
1335:  BSF    03.6
1336:  MOVWF  11
1337:  BCF    03.6
1338:  MOVF   6D,W
1339:  BSF    03.6
133A:  MOVWF  10
133B:  CLRF   17
133C:  CLRF   16
133D:  MOVLW  03
133E:  MOVWF  15
133F:  MOVLW  E8
1340:  MOVWF  14
1341:  BCF    0A.4
1342:  BCF    03.6
1343:  CALL   1A9
1344:  BSF    0A.4
1345:  BSF    03.5
1346:  MOVF   23,W
1347:  MOVWF  27
1348:  MOVF   22,W
1349:  MOVWF  26
134A:  MOVF   21,W
134B:  MOVWF  25
134C:  MOVF   20,W
134D:  MOVWF  24
134E:  CLRF   29
134F:  MOVF   04,W
1350:  MOVWF  28
1351:  BCF    29.0
1352:  BTFSC  03.7
1353:  BSF    29.0
1354:  BCF    03.1
1355:  MOVF   27,W
1356:  BCF    03.5
1357:  BSF    03.6
1358:  MOVWF  13
1359:  BSF    03.5
135A:  BCF    03.6
135B:  MOVF   26,W
135C:  BCF    03.5
135D:  BSF    03.6
135E:  MOVWF  12
135F:  BSF    03.5
1360:  BCF    03.6
1361:  MOVF   25,W
1362:  BCF    03.5
1363:  BSF    03.6
1364:  MOVWF  11
1365:  BSF    03.5
1366:  BCF    03.6
1367:  MOVF   24,W
1368:  BCF    03.5
1369:  BSF    03.6
136A:  MOVWF  10
136B:  CLRF   17
136C:  CLRF   16
136D:  CLRF   15
136E:  MOVLW  64
136F:  MOVWF  14
1370:  BCF    0A.4
1371:  BCF    03.6
1372:  CALL   1A9
1373:  BSF    0A.4
1374:  BSF    03.5
1375:  MOVF   28,W
1376:  MOVWF  04
1377:  BCF    03.7
1378:  BTFSC  29.0
1379:  BSF    03.7
137A:  MOVF   7A,W
137B:  MOVWF  27
137C:  MOVF   79,W
137D:  MOVWF  26
137E:  MOVF   78,W
137F:  MOVWF  25
1380:  MOVF   77,W
1381:  MOVWF  24
1382:  MOVLW  30
1383:  ADDWF  24,F
1384:  MOVLW  00
1385:  BTFSC  03.0
1386:  MOVLW  01
1387:  ADDWF  25,F
1388:  MOVLW  00
1389:  BTFSC  03.0
138A:  MOVLW  01
138B:  ADDWF  26,F
138C:  MOVLW  00
138D:  BTFSC  03.0
138E:  MOVLW  01
138F:  ADDWF  27,F
1390:  MOVF   24,W
1391:  MOVWF  2A
1392:  BCF    0A.4
1393:  BCF    03.5
1394:  CALL   26F
1395:  BSF    0A.4
....................          LCD_PutChar((num % 100) / 10 + '0'); 
1396:  BSF    03.1
1397:  MOVLW  A0
1398:  MOVWF  04
1399:  BCF    03.7
139A:  MOVF   70,W
139B:  BSF    03.6
139C:  MOVWF  13
139D:  BCF    03.6
139E:  MOVF   6F,W
139F:  BSF    03.6
13A0:  MOVWF  12
13A1:  BCF    03.6
13A2:  MOVF   6E,W
13A3:  BSF    03.6
13A4:  MOVWF  11
13A5:  BCF    03.6
13A6:  MOVF   6D,W
13A7:  BSF    03.6
13A8:  MOVWF  10
13A9:  CLRF   17
13AA:  CLRF   16
13AB:  CLRF   15
13AC:  MOVLW  64
13AD:  MOVWF  14
13AE:  BCF    0A.4
13AF:  BCF    03.6
13B0:  CALL   1A9
13B1:  BSF    0A.4
13B2:  BSF    03.5
13B3:  MOVF   23,W
13B4:  MOVWF  27
13B5:  MOVF   22,W
13B6:  MOVWF  26
13B7:  MOVF   21,W
13B8:  MOVWF  25
13B9:  MOVF   20,W
13BA:  MOVWF  24
13BB:  CLRF   29
13BC:  MOVF   04,W
13BD:  MOVWF  28
13BE:  BCF    29.0
13BF:  BTFSC  03.7
13C0:  BSF    29.0
13C1:  BCF    03.1
13C2:  MOVF   27,W
13C3:  BCF    03.5
13C4:  BSF    03.6
13C5:  MOVWF  13
13C6:  BSF    03.5
13C7:  BCF    03.6
13C8:  MOVF   26,W
13C9:  BCF    03.5
13CA:  BSF    03.6
13CB:  MOVWF  12
13CC:  BSF    03.5
13CD:  BCF    03.6
13CE:  MOVF   25,W
13CF:  BCF    03.5
13D0:  BSF    03.6
13D1:  MOVWF  11
13D2:  BSF    03.5
13D3:  BCF    03.6
13D4:  MOVF   24,W
13D5:  BCF    03.5
13D6:  BSF    03.6
13D7:  MOVWF  10
13D8:  CLRF   17
13D9:  CLRF   16
13DA:  CLRF   15
13DB:  MOVLW  0A
13DC:  MOVWF  14
13DD:  BCF    0A.4
13DE:  BCF    03.6
13DF:  CALL   1A9
13E0:  BSF    0A.4
13E1:  BSF    03.5
13E2:  MOVF   28,W
13E3:  MOVWF  04
13E4:  BCF    03.7
13E5:  BTFSC  29.0
13E6:  BSF    03.7
13E7:  MOVF   7A,W
13E8:  MOVWF  27
13E9:  MOVF   79,W
13EA:  MOVWF  26
13EB:  MOVF   78,W
13EC:  MOVWF  25
13ED:  MOVF   77,W
13EE:  MOVWF  24
13EF:  MOVLW  30
13F0:  ADDWF  24,F
13F1:  MOVLW  00
13F2:  BTFSC  03.0
13F3:  MOVLW  01
13F4:  ADDWF  25,F
13F5:  MOVLW  00
13F6:  BTFSC  03.0
13F7:  MOVLW  01
13F8:  ADDWF  26,F
13F9:  MOVLW  00
13FA:  BTFSC  03.0
13FB:  MOVLW  01
13FC:  ADDWF  27,F
13FD:  MOVF   24,W
13FE:  MOVWF  2A
13FF:  BCF    0A.4
1400:  BCF    03.5
1401:  CALL   26F
1402:  BSF    0A.4
....................          LCD_PutChar(num % 10 + '0'); 
1403:  BSF    03.1
1404:  MOVLW  A0
1405:  MOVWF  04
1406:  BCF    03.7
1407:  MOVF   70,W
1408:  BSF    03.6
1409:  MOVWF  13
140A:  BCF    03.6
140B:  MOVF   6F,W
140C:  BSF    03.6
140D:  MOVWF  12
140E:  BCF    03.6
140F:  MOVF   6E,W
1410:  BSF    03.6
1411:  MOVWF  11
1412:  BCF    03.6
1413:  MOVF   6D,W
1414:  BSF    03.6
1415:  MOVWF  10
1416:  CLRF   17
1417:  CLRF   16
1418:  CLRF   15
1419:  MOVLW  0A
141A:  MOVWF  14
141B:  BCF    0A.4
141C:  BCF    03.6
141D:  CALL   1A9
141E:  BSF    0A.4
141F:  BSF    03.5
1420:  MOVF   23,W
1421:  MOVWF  27
1422:  MOVF   22,W
1423:  MOVWF  26
1424:  MOVF   21,W
1425:  MOVWF  25
1426:  MOVF   20,W
1427:  MOVWF  24
1428:  MOVLW  30
1429:  ADDWF  24,F
142A:  MOVLW  00
142B:  BTFSC  03.0
142C:  MOVLW  01
142D:  ADDWF  25,F
142E:  MOVLW  00
142F:  BTFSC  03.0
1430:  MOVLW  01
1431:  ADDWF  26,F
1432:  MOVLW  00
1433:  BTFSC  03.0
1434:  MOVLW  01
1435:  ADDWF  27,F
1436:  MOVF   24,W
1437:  MOVWF  2A
1438:  BCF    0A.4
1439:  BCF    03.5
143A:  CALL   26F
143B:  BSF    0A.4
....................       } else if (num >= 1000) { 
143C:  GOTO   767
143D:  MOVF   70,F
143E:  BTFSS  03.2
143F:  GOTO   44E
1440:  MOVF   6F,F
1441:  BTFSS  03.2
1442:  GOTO   44E
1443:  MOVF   6E,W
1444:  SUBLW  02
1445:  BTFSC  03.0
1446:  GOTO   5A1
1447:  XORLW  FF
1448:  BTFSS  03.2
1449:  GOTO   44E
144A:  MOVF   6D,W
144B:  SUBLW  E7
144C:  BTFSC  03.0
144D:  GOTO   5A1
....................          LCD_PutChar(' '); 
144E:  MOVLW  20
144F:  BSF    03.5
1450:  MOVWF  2A
1451:  BCF    0A.4
1452:  BCF    03.5
1453:  CALL   26F
1454:  BSF    0A.4
....................          LCD_PutChar(num / 1000 + '0'); 
1455:  BCF    03.1
1456:  MOVF   70,W
1457:  BSF    03.6
1458:  MOVWF  13
1459:  BCF    03.6
145A:  MOVF   6F,W
145B:  BSF    03.6
145C:  MOVWF  12
145D:  BCF    03.6
145E:  MOVF   6E,W
145F:  BSF    03.6
1460:  MOVWF  11
1461:  BCF    03.6
1462:  MOVF   6D,W
1463:  BSF    03.6
1464:  MOVWF  10
1465:  CLRF   17
1466:  CLRF   16
1467:  MOVLW  03
1468:  MOVWF  15
1469:  MOVLW  E8
146A:  MOVWF  14
146B:  BCF    0A.4
146C:  BCF    03.6
146D:  CALL   1A9
146E:  BSF    0A.4
146F:  MOVF   7A,W
1470:  BSF    03.5
1471:  MOVWF  23
1472:  MOVF   79,W
1473:  MOVWF  22
1474:  MOVF   78,W
1475:  MOVWF  21
1476:  MOVF   77,W
1477:  MOVWF  20
1478:  MOVLW  30
1479:  ADDWF  20,F
147A:  MOVLW  00
147B:  BTFSC  03.0
147C:  MOVLW  01
147D:  ADDWF  21,F
147E:  MOVLW  00
147F:  BTFSC  03.0
1480:  MOVLW  01
1481:  ADDWF  22,F
1482:  MOVLW  00
1483:  BTFSC  03.0
1484:  MOVLW  01
1485:  ADDWF  23,F
1486:  MOVF   20,W
1487:  MOVWF  2A
1488:  BCF    0A.4
1489:  BCF    03.5
148A:  CALL   26F
148B:  BSF    0A.4
....................          LCD_PutChar((num % 1000) / 100 + '0'); 
148C:  BSF    03.1
148D:  MOVLW  A0
148E:  MOVWF  04
148F:  BCF    03.7
1490:  MOVF   70,W
1491:  BSF    03.6
1492:  MOVWF  13
1493:  BCF    03.6
1494:  MOVF   6F,W
1495:  BSF    03.6
1496:  MOVWF  12
1497:  BCF    03.6
1498:  MOVF   6E,W
1499:  BSF    03.6
149A:  MOVWF  11
149B:  BCF    03.6
149C:  MOVF   6D,W
149D:  BSF    03.6
149E:  MOVWF  10
149F:  CLRF   17
14A0:  CLRF   16
14A1:  MOVLW  03
14A2:  MOVWF  15
14A3:  MOVLW  E8
14A4:  MOVWF  14
14A5:  BCF    0A.4
14A6:  BCF    03.6
14A7:  CALL   1A9
14A8:  BSF    0A.4
14A9:  BSF    03.5
14AA:  MOVF   23,W
14AB:  MOVWF  27
14AC:  MOVF   22,W
14AD:  MOVWF  26
14AE:  MOVF   21,W
14AF:  MOVWF  25
14B0:  MOVF   20,W
14B1:  MOVWF  24
14B2:  CLRF   29
14B3:  MOVF   04,W
14B4:  MOVWF  28
14B5:  BCF    29.0
14B6:  BTFSC  03.7
14B7:  BSF    29.0
14B8:  BCF    03.1
14B9:  MOVF   27,W
14BA:  BCF    03.5
14BB:  BSF    03.6
14BC:  MOVWF  13
14BD:  BSF    03.5
14BE:  BCF    03.6
14BF:  MOVF   26,W
14C0:  BCF    03.5
14C1:  BSF    03.6
14C2:  MOVWF  12
14C3:  BSF    03.5
14C4:  BCF    03.6
14C5:  MOVF   25,W
14C6:  BCF    03.5
14C7:  BSF    03.6
14C8:  MOVWF  11
14C9:  BSF    03.5
14CA:  BCF    03.6
14CB:  MOVF   24,W
14CC:  BCF    03.5
14CD:  BSF    03.6
14CE:  MOVWF  10
14CF:  CLRF   17
14D0:  CLRF   16
14D1:  CLRF   15
14D2:  MOVLW  64
14D3:  MOVWF  14
14D4:  BCF    0A.4
14D5:  BCF    03.6
14D6:  CALL   1A9
14D7:  BSF    0A.4
14D8:  BSF    03.5
14D9:  MOVF   28,W
14DA:  MOVWF  04
14DB:  BCF    03.7
14DC:  BTFSC  29.0
14DD:  BSF    03.7
14DE:  MOVF   7A,W
14DF:  MOVWF  27
14E0:  MOVF   79,W
14E1:  MOVWF  26
14E2:  MOVF   78,W
14E3:  MOVWF  25
14E4:  MOVF   77,W
14E5:  MOVWF  24
14E6:  MOVLW  30
14E7:  ADDWF  24,F
14E8:  MOVLW  00
14E9:  BTFSC  03.0
14EA:  MOVLW  01
14EB:  ADDWF  25,F
14EC:  MOVLW  00
14ED:  BTFSC  03.0
14EE:  MOVLW  01
14EF:  ADDWF  26,F
14F0:  MOVLW  00
14F1:  BTFSC  03.0
14F2:  MOVLW  01
14F3:  ADDWF  27,F
14F4:  MOVF   24,W
14F5:  MOVWF  2A
14F6:  BCF    0A.4
14F7:  BCF    03.5
14F8:  CALL   26F
14F9:  BSF    0A.4
....................          LCD_PutChar((num % 100) / 10 + '0'); 
14FA:  BSF    03.1
14FB:  MOVLW  A0
14FC:  MOVWF  04
14FD:  BCF    03.7
14FE:  MOVF   70,W
14FF:  BSF    03.6
1500:  MOVWF  13
1501:  BCF    03.6
1502:  MOVF   6F,W
1503:  BSF    03.6
1504:  MOVWF  12
1505:  BCF    03.6
1506:  MOVF   6E,W
1507:  BSF    03.6
1508:  MOVWF  11
1509:  BCF    03.6
150A:  MOVF   6D,W
150B:  BSF    03.6
150C:  MOVWF  10
150D:  CLRF   17
150E:  CLRF   16
150F:  CLRF   15
1510:  MOVLW  64
1511:  MOVWF  14
1512:  BCF    0A.4
1513:  BCF    03.6
1514:  CALL   1A9
1515:  BSF    0A.4
1516:  BSF    03.5
1517:  MOVF   23,W
1518:  MOVWF  27
1519:  MOVF   22,W
151A:  MOVWF  26
151B:  MOVF   21,W
151C:  MOVWF  25
151D:  MOVF   20,W
151E:  MOVWF  24
151F:  CLRF   29
1520:  MOVF   04,W
1521:  MOVWF  28
1522:  BCF    29.0
1523:  BTFSC  03.7
1524:  BSF    29.0
1525:  BCF    03.1
1526:  MOVF   27,W
1527:  BCF    03.5
1528:  BSF    03.6
1529:  MOVWF  13
152A:  BSF    03.5
152B:  BCF    03.6
152C:  MOVF   26,W
152D:  BCF    03.5
152E:  BSF    03.6
152F:  MOVWF  12
1530:  BSF    03.5
1531:  BCF    03.6
1532:  MOVF   25,W
1533:  BCF    03.5
1534:  BSF    03.6
1535:  MOVWF  11
1536:  BSF    03.5
1537:  BCF    03.6
1538:  MOVF   24,W
1539:  BCF    03.5
153A:  BSF    03.6
153B:  MOVWF  10
153C:  CLRF   17
153D:  CLRF   16
153E:  CLRF   15
153F:  MOVLW  0A
1540:  MOVWF  14
1541:  BCF    0A.4
1542:  BCF    03.6
1543:  CALL   1A9
1544:  BSF    0A.4
1545:  BSF    03.5
1546:  MOVF   28,W
1547:  MOVWF  04
1548:  BCF    03.7
1549:  BTFSC  29.0
154A:  BSF    03.7
154B:  MOVF   7A,W
154C:  MOVWF  27
154D:  MOVF   79,W
154E:  MOVWF  26
154F:  MOVF   78,W
1550:  MOVWF  25
1551:  MOVF   77,W
1552:  MOVWF  24
1553:  MOVLW  30
1554:  ADDWF  24,F
1555:  MOVLW  00
1556:  BTFSC  03.0
1557:  MOVLW  01
1558:  ADDWF  25,F
1559:  MOVLW  00
155A:  BTFSC  03.0
155B:  MOVLW  01
155C:  ADDWF  26,F
155D:  MOVLW  00
155E:  BTFSC  03.0
155F:  MOVLW  01
1560:  ADDWF  27,F
1561:  MOVF   24,W
1562:  MOVWF  2A
1563:  BCF    0A.4
1564:  BCF    03.5
1565:  CALL   26F
1566:  BSF    0A.4
....................          LCD_PutChar(num % 10 + '0'); 
1567:  BSF    03.1
1568:  MOVLW  A0
1569:  MOVWF  04
156A:  BCF    03.7
156B:  MOVF   70,W
156C:  BSF    03.6
156D:  MOVWF  13
156E:  BCF    03.6
156F:  MOVF   6F,W
1570:  BSF    03.6
1571:  MOVWF  12
1572:  BCF    03.6
1573:  MOVF   6E,W
1574:  BSF    03.6
1575:  MOVWF  11
1576:  BCF    03.6
1577:  MOVF   6D,W
1578:  BSF    03.6
1579:  MOVWF  10
157A:  CLRF   17
157B:  CLRF   16
157C:  CLRF   15
157D:  MOVLW  0A
157E:  MOVWF  14
157F:  BCF    0A.4
1580:  BCF    03.6
1581:  CALL   1A9
1582:  BSF    0A.4
1583:  BSF    03.5
1584:  MOVF   23,W
1585:  MOVWF  27
1586:  MOVF   22,W
1587:  MOVWF  26
1588:  MOVF   21,W
1589:  MOVWF  25
158A:  MOVF   20,W
158B:  MOVWF  24
158C:  MOVLW  30
158D:  ADDWF  24,F
158E:  MOVLW  00
158F:  BTFSC  03.0
1590:  MOVLW  01
1591:  ADDWF  25,F
1592:  MOVLW  00
1593:  BTFSC  03.0
1594:  MOVLW  01
1595:  ADDWF  26,F
1596:  MOVLW  00
1597:  BTFSC  03.0
1598:  MOVLW  01
1599:  ADDWF  27,F
159A:  MOVF   24,W
159B:  MOVWF  2A
159C:  BCF    0A.4
159D:  BCF    03.5
159E:  CALL   26F
159F:  BSF    0A.4
....................       } else if (num >= 100) { 
15A0:  GOTO   767
15A1:  MOVF   70,F
15A2:  BTFSS  03.2
15A3:  GOTO   5AE
15A4:  MOVF   6F,F
15A5:  BTFSS  03.2
15A6:  GOTO   5AE
15A7:  MOVF   6E,F
15A8:  BTFSS  03.2
15A9:  GOTO   5AE
15AA:  MOVF   6D,W
15AB:  SUBLW  63
15AC:  BTFSC  03.0
15AD:  GOTO   699
....................          LCD_PutChar(' '); 
15AE:  MOVLW  20
15AF:  BSF    03.5
15B0:  MOVWF  2A
15B1:  BCF    0A.4
15B2:  BCF    03.5
15B3:  CALL   26F
15B4:  BSF    0A.4
....................          LCD_PutChar(' '); 
15B5:  MOVLW  20
15B6:  BSF    03.5
15B7:  MOVWF  2A
15B8:  BCF    0A.4
15B9:  BCF    03.5
15BA:  CALL   26F
15BB:  BSF    0A.4
....................          LCD_PutChar(num / 100 + '0'); 
15BC:  BCF    03.1
15BD:  MOVF   70,W
15BE:  BSF    03.6
15BF:  MOVWF  13
15C0:  BCF    03.6
15C1:  MOVF   6F,W
15C2:  BSF    03.6
15C3:  MOVWF  12
15C4:  BCF    03.6
15C5:  MOVF   6E,W
15C6:  BSF    03.6
15C7:  MOVWF  11
15C8:  BCF    03.6
15C9:  MOVF   6D,W
15CA:  BSF    03.6
15CB:  MOVWF  10
15CC:  CLRF   17
15CD:  CLRF   16
15CE:  CLRF   15
15CF:  MOVLW  64
15D0:  MOVWF  14
15D1:  BCF    0A.4
15D2:  BCF    03.6
15D3:  CALL   1A9
15D4:  BSF    0A.4
15D5:  MOVF   7A,W
15D6:  BSF    03.5
15D7:  MOVWF  23
15D8:  MOVF   79,W
15D9:  MOVWF  22
15DA:  MOVF   78,W
15DB:  MOVWF  21
15DC:  MOVF   77,W
15DD:  MOVWF  20
15DE:  MOVLW  30
15DF:  ADDWF  20,F
15E0:  MOVLW  00
15E1:  BTFSC  03.0
15E2:  MOVLW  01
15E3:  ADDWF  21,F
15E4:  MOVLW  00
15E5:  BTFSC  03.0
15E6:  MOVLW  01
15E7:  ADDWF  22,F
15E8:  MOVLW  00
15E9:  BTFSC  03.0
15EA:  MOVLW  01
15EB:  ADDWF  23,F
15EC:  MOVF   20,W
15ED:  MOVWF  2A
15EE:  BCF    0A.4
15EF:  BCF    03.5
15F0:  CALL   26F
15F1:  BSF    0A.4
....................          LCD_PutChar((num % 100) / 10 + '0'); 
15F2:  BSF    03.1
15F3:  MOVLW  A0
15F4:  MOVWF  04
15F5:  BCF    03.7
15F6:  MOVF   70,W
15F7:  BSF    03.6
15F8:  MOVWF  13
15F9:  BCF    03.6
15FA:  MOVF   6F,W
15FB:  BSF    03.6
15FC:  MOVWF  12
15FD:  BCF    03.6
15FE:  MOVF   6E,W
15FF:  BSF    03.6
1600:  MOVWF  11
1601:  BCF    03.6
1602:  MOVF   6D,W
1603:  BSF    03.6
1604:  MOVWF  10
1605:  CLRF   17
1606:  CLRF   16
1607:  CLRF   15
1608:  MOVLW  64
1609:  MOVWF  14
160A:  BCF    0A.4
160B:  BCF    03.6
160C:  CALL   1A9
160D:  BSF    0A.4
160E:  BSF    03.5
160F:  MOVF   23,W
1610:  MOVWF  27
1611:  MOVF   22,W
1612:  MOVWF  26
1613:  MOVF   21,W
1614:  MOVWF  25
1615:  MOVF   20,W
1616:  MOVWF  24
1617:  CLRF   29
1618:  MOVF   04,W
1619:  MOVWF  28
161A:  BCF    29.0
161B:  BTFSC  03.7
161C:  BSF    29.0
161D:  BCF    03.1
161E:  MOVF   27,W
161F:  BCF    03.5
1620:  BSF    03.6
1621:  MOVWF  13
1622:  BSF    03.5
1623:  BCF    03.6
1624:  MOVF   26,W
1625:  BCF    03.5
1626:  BSF    03.6
1627:  MOVWF  12
1628:  BSF    03.5
1629:  BCF    03.6
162A:  MOVF   25,W
162B:  BCF    03.5
162C:  BSF    03.6
162D:  MOVWF  11
162E:  BSF    03.5
162F:  BCF    03.6
1630:  MOVF   24,W
1631:  BCF    03.5
1632:  BSF    03.6
1633:  MOVWF  10
1634:  CLRF   17
1635:  CLRF   16
1636:  CLRF   15
1637:  MOVLW  0A
1638:  MOVWF  14
1639:  BCF    0A.4
163A:  BCF    03.6
163B:  CALL   1A9
163C:  BSF    0A.4
163D:  BSF    03.5
163E:  MOVF   28,W
163F:  MOVWF  04
1640:  BCF    03.7
1641:  BTFSC  29.0
1642:  BSF    03.7
1643:  MOVF   7A,W
1644:  MOVWF  27
1645:  MOVF   79,W
1646:  MOVWF  26
1647:  MOVF   78,W
1648:  MOVWF  25
1649:  MOVF   77,W
164A:  MOVWF  24
164B:  MOVLW  30
164C:  ADDWF  24,F
164D:  MOVLW  00
164E:  BTFSC  03.0
164F:  MOVLW  01
1650:  ADDWF  25,F
1651:  MOVLW  00
1652:  BTFSC  03.0
1653:  MOVLW  01
1654:  ADDWF  26,F
1655:  MOVLW  00
1656:  BTFSC  03.0
1657:  MOVLW  01
1658:  ADDWF  27,F
1659:  MOVF   24,W
165A:  MOVWF  2A
165B:  BCF    0A.4
165C:  BCF    03.5
165D:  CALL   26F
165E:  BSF    0A.4
....................          LCD_PutChar(num % 10 + '0'); 
165F:  BSF    03.1
1660:  MOVLW  A0
1661:  MOVWF  04
1662:  BCF    03.7
1663:  MOVF   70,W
1664:  BSF    03.6
1665:  MOVWF  13
1666:  BCF    03.6
1667:  MOVF   6F,W
1668:  BSF    03.6
1669:  MOVWF  12
166A:  BCF    03.6
166B:  MOVF   6E,W
166C:  BSF    03.6
166D:  MOVWF  11
166E:  BCF    03.6
166F:  MOVF   6D,W
1670:  BSF    03.6
1671:  MOVWF  10
1672:  CLRF   17
1673:  CLRF   16
1674:  CLRF   15
1675:  MOVLW  0A
1676:  MOVWF  14
1677:  BCF    0A.4
1678:  BCF    03.6
1679:  CALL   1A9
167A:  BSF    0A.4
167B:  BSF    03.5
167C:  MOVF   23,W
167D:  MOVWF  27
167E:  MOVF   22,W
167F:  MOVWF  26
1680:  MOVF   21,W
1681:  MOVWF  25
1682:  MOVF   20,W
1683:  MOVWF  24
1684:  MOVLW  30
1685:  ADDWF  24,F
1686:  MOVLW  00
1687:  BTFSC  03.0
1688:  MOVLW  01
1689:  ADDWF  25,F
168A:  MOVLW  00
168B:  BTFSC  03.0
168C:  MOVLW  01
168D:  ADDWF  26,F
168E:  MOVLW  00
168F:  BTFSC  03.0
1690:  MOVLW  01
1691:  ADDWF  27,F
1692:  MOVF   24,W
1693:  MOVWF  2A
1694:  BCF    0A.4
1695:  BCF    03.5
1696:  CALL   26F
1697:  BSF    0A.4
....................       } else if (num >= 10) { 
1698:  GOTO   767
1699:  MOVF   70,F
169A:  BTFSS  03.2
169B:  GOTO   6A6
169C:  MOVF   6F,F
169D:  BTFSS  03.2
169E:  GOTO   6A6
169F:  MOVF   6E,F
16A0:  BTFSS  03.2
16A1:  GOTO   6A6
16A2:  MOVF   6D,W
16A3:  SUBLW  09
16A4:  BTFSC  03.0
16A5:  GOTO   72B
....................          LCD_PutChar(' '); 
16A6:  MOVLW  20
16A7:  BSF    03.5
16A8:  MOVWF  2A
16A9:  BCF    0A.4
16AA:  BCF    03.5
16AB:  CALL   26F
16AC:  BSF    0A.4
....................          LCD_PutChar(' '); 
16AD:  MOVLW  20
16AE:  BSF    03.5
16AF:  MOVWF  2A
16B0:  BCF    0A.4
16B1:  BCF    03.5
16B2:  CALL   26F
16B3:  BSF    0A.4
....................          LCD_PutChar(' '); 
16B4:  MOVLW  20
16B5:  BSF    03.5
16B6:  MOVWF  2A
16B7:  BCF    0A.4
16B8:  BCF    03.5
16B9:  CALL   26F
16BA:  BSF    0A.4
....................          LCD_PutChar(num / 10 + '0'); 
16BB:  BCF    03.1
16BC:  MOVF   70,W
16BD:  BSF    03.6
16BE:  MOVWF  13
16BF:  BCF    03.6
16C0:  MOVF   6F,W
16C1:  BSF    03.6
16C2:  MOVWF  12
16C3:  BCF    03.6
16C4:  MOVF   6E,W
16C5:  BSF    03.6
16C6:  MOVWF  11
16C7:  BCF    03.6
16C8:  MOVF   6D,W
16C9:  BSF    03.6
16CA:  MOVWF  10
16CB:  CLRF   17
16CC:  CLRF   16
16CD:  CLRF   15
16CE:  MOVLW  0A
16CF:  MOVWF  14
16D0:  BCF    0A.4
16D1:  BCF    03.6
16D2:  CALL   1A9
16D3:  BSF    0A.4
16D4:  MOVF   7A,W
16D5:  BSF    03.5
16D6:  MOVWF  23
16D7:  MOVF   79,W
16D8:  MOVWF  22
16D9:  MOVF   78,W
16DA:  MOVWF  21
16DB:  MOVF   77,W
16DC:  MOVWF  20
16DD:  MOVLW  30
16DE:  ADDWF  20,F
16DF:  MOVLW  00
16E0:  BTFSC  03.0
16E1:  MOVLW  01
16E2:  ADDWF  21,F
16E3:  MOVLW  00
16E4:  BTFSC  03.0
16E5:  MOVLW  01
16E6:  ADDWF  22,F
16E7:  MOVLW  00
16E8:  BTFSC  03.0
16E9:  MOVLW  01
16EA:  ADDWF  23,F
16EB:  MOVF   20,W
16EC:  MOVWF  2A
16ED:  BCF    0A.4
16EE:  BCF    03.5
16EF:  CALL   26F
16F0:  BSF    0A.4
....................          LCD_PutChar(num % 10 + '0'); 
16F1:  BSF    03.1
16F2:  MOVLW  A0
16F3:  MOVWF  04
16F4:  BCF    03.7
16F5:  MOVF   70,W
16F6:  BSF    03.6
16F7:  MOVWF  13
16F8:  BCF    03.6
16F9:  MOVF   6F,W
16FA:  BSF    03.6
16FB:  MOVWF  12
16FC:  BCF    03.6
16FD:  MOVF   6E,W
16FE:  BSF    03.6
16FF:  MOVWF  11
1700:  BCF    03.6
1701:  MOVF   6D,W
1702:  BSF    03.6
1703:  MOVWF  10
1704:  CLRF   17
1705:  CLRF   16
1706:  CLRF   15
1707:  MOVLW  0A
1708:  MOVWF  14
1709:  BCF    0A.4
170A:  BCF    03.6
170B:  CALL   1A9
170C:  BSF    0A.4
170D:  BSF    03.5
170E:  MOVF   23,W
170F:  MOVWF  27
1710:  MOVF   22,W
1711:  MOVWF  26
1712:  MOVF   21,W
1713:  MOVWF  25
1714:  MOVF   20,W
1715:  MOVWF  24
1716:  MOVLW  30
1717:  ADDWF  24,F
1718:  MOVLW  00
1719:  BTFSC  03.0
171A:  MOVLW  01
171B:  ADDWF  25,F
171C:  MOVLW  00
171D:  BTFSC  03.0
171E:  MOVLW  01
171F:  ADDWF  26,F
1720:  MOVLW  00
1721:  BTFSC  03.0
1722:  MOVLW  01
1723:  ADDWF  27,F
1724:  MOVF   24,W
1725:  MOVWF  2A
1726:  BCF    0A.4
1727:  BCF    03.5
1728:  CALL   26F
1729:  BSF    0A.4
....................       } else { 
172A:  GOTO   767
....................          LCD_PutChar(' '); 
172B:  MOVLW  20
172C:  BSF    03.5
172D:  MOVWF  2A
172E:  BCF    0A.4
172F:  BCF    03.5
1730:  CALL   26F
1731:  BSF    0A.4
....................          LCD_PutChar(' '); 
1732:  MOVLW  20
1733:  BSF    03.5
1734:  MOVWF  2A
1735:  BCF    0A.4
1736:  BCF    03.5
1737:  CALL   26F
1738:  BSF    0A.4
....................          LCD_PutChar(' '); 
1739:  MOVLW  20
173A:  BSF    03.5
173B:  MOVWF  2A
173C:  BCF    0A.4
173D:  BCF    03.5
173E:  CALL   26F
173F:  BSF    0A.4
....................          LCD_PutChar(' '); 
1740:  MOVLW  20
1741:  BSF    03.5
1742:  MOVWF  2A
1743:  BCF    0A.4
1744:  BCF    03.5
1745:  CALL   26F
1746:  BSF    0A.4
....................          LCD_PutChar(num + '0'); 
1747:  MOVLW  30
1748:  ADDWF  6D,W
1749:  BSF    03.5
174A:  MOVWF  20
174B:  BCF    03.5
174C:  MOVF   6E,W
174D:  BSF    03.5
174E:  MOVWF  21
174F:  MOVLW  00
1750:  BTFSC  03.0
1751:  MOVLW  01
1752:  ADDWF  21,F
1753:  BCF    03.5
1754:  MOVF   6F,W
1755:  BSF    03.5
1756:  MOVWF  22
1757:  MOVLW  00
1758:  BTFSC  03.0
1759:  MOVLW  01
175A:  ADDWF  22,F
175B:  MOVF   70,W
175C:  MOVWF  23
175D:  MOVLW  00
175E:  BTFSC  03.0
175F:  MOVLW  01
1760:  ADDWF  23,F
1761:  MOVF   20,W
1762:  MOVWF  2A
1763:  BCF    0A.4
1764:  BCF    03.5
1765:  CALL   26F
1766:  BSF    0A.4
....................       } 
....................    } 
....................    delay_us(20); 
1767:  MOVLW  0D
1768:  MOVWF  77
1769:  DECFSZ 77,F
176A:  GOTO   769
176B:  RETURN
.................... } 
....................  
.................... void main() { 
*
1800:  MOVF   03,W
1801:  ANDLW  1F
1802:  MOVWF  03
1803:  CLRF   21
1804:  CLRF   20
1805:  CLRF   23
1806:  CLRF   22
1807:  BCF    24.0
1808:  CLRF   25
1809:  CLRF   27
180A:  CLRF   26
180B:  CLRF   29
180C:  CLRF   28
180D:  BCF    24.1
180E:  CLRF   2A
180F:  CLRF   2B
1810:  CLRF   2C
1811:  CLRF   4D
1812:  BCF    24.2
1813:  CLRF   4F
1814:  CLRF   4E
1815:  CLRF   53
1816:  CLRF   52
1817:  CLRF   51
1818:  MOVLW  7F
1819:  MOVWF  50
181A:  CLRF   54
181B:  CLRF   55
181C:  MOVLW  0C
181D:  BSF    03.5
181E:  MOVWF  19
181F:  MOVLW  A2
1820:  MOVWF  18
1821:  MOVLW  90
1822:  BCF    03.5
1823:  MOVWF  18
1824:  CLRF   59
1825:  CLRF   58
1826:  BCF    24.3
1827:  BSF    03.5
1828:  BSF    1F.0
1829:  BSF    1F.1
182A:  BSF    1F.2
182B:  BCF    1F.3
182C:  MOVLW  07
182D:  MOVWF  1C
182E:  BCF    03.7
....................    set_tris_d(0x00); // LCD on PORTD (output) 
*
1852:  MOVLW  00
1853:  BSF    03.5
1854:  MOVWF  08
....................    set_tris_c(0b00011000); // PORTC for I2C (RC3, RC4 as input for I2C) 
1855:  MOVLW  18
1856:  MOVWF  07
....................    set_tris_b(0xFF); // PORTB as input (for DHT11) 
1857:  MOVLW  FF
1858:  MOVWF  06
....................    set_tris_a(0x01); // A0 as input for HX711 DT, A1 as output for HX711 SCK 
1859:  MOVLW  01
185A:  MOVWF  05
....................  
....................    // Initialize modules 
....................    LCD_Init(); 
185B:  BCF    0A.4
185C:  BCF    0A.3
185D:  BCF    03.5
185E:  GOTO   060
185F:  BSF    0A.4
1860:  BSF    0A.3
....................    delay_ms(50); 
1861:  MOVLW  32
1862:  BSF    03.5
1863:  MOVWF  2C
1864:  BCF    0A.4
1865:  BCF    0A.3
1866:  BCF    03.5
1867:  CALL   02E
1868:  BSF    0A.4
1869:  BSF    0A.3
....................    max30102_init(); // Kh?i t?o MAX30102 và reset các giá tr? 
186A:  BCF    0A.4
186B:  BCF    0A.3
186C:  GOTO   0EE
186D:  BSF    0A.4
186E:  BSF    0A.3
....................    uart_init(); // Gi? s? hàm này t?n t?i và ho?t d?ng 
186F:  BCF    0A.4
1870:  BCF    0A.3
1871:  GOTO   144
1872:  BSF    0A.4
1873:  BSF    0A.3
....................  
....................    // Skip initial HX711 readings for stability 
....................    for (int i = 0; i < 5; i++) { 
1874:  CLRF   5A
1875:  MOVF   5A,W
1876:  SUBLW  04
1877:  BTFSS  03.0
1878:  GOTO   089
....................       readCount(); // Hàm t? hx711.h 
1879:  BCF    0A.4
187A:  BCF    0A.3
187B:  CALL   147
187C:  BSF    0A.4
187D:  BSF    0A.3
....................       delay_ms(10); 
187E:  MOVLW  0A
187F:  BSF    03.5
1880:  MOVWF  2C
1881:  BCF    0A.4
1882:  BCF    0A.3
1883:  BCF    03.5
1884:  CALL   02E
1885:  BSF    0A.4
1886:  BSF    0A.3
1887:  INCF   5A,F
1888:  GOTO   075
....................    } 
....................    // Initial tare 
....................    hx711_tare(1); 
1889:  MOVLW  01
188A:  MOVWF  6D
188B:  BCF    0A.4
188C:  BCF    0A.3
188D:  CALL   25F
188E:  BSF    0A.4
188F:  BSF    0A.3
....................    delay_ms(100); // Ch? tare ?n d?nh hon m?t chút 
1890:  MOVLW  64
1891:  BSF    03.5
1892:  MOVWF  2C
1893:  BCF    0A.4
1894:  BCF    0A.3
1895:  BCF    03.5
1896:  CALL   02E
1897:  BSF    0A.4
1898:  BSF    0A.3
....................  
....................    // Display static labels with units (cách hi?n th? ban d?u c?a b?n) 
....................    LCD_SetPosition(LINE_1); 
1899:  MOVLW  80
189A:  BSF    03.5
189B:  MOVWF  20
189C:  BCF    0A.4
189D:  BCF    0A.3
189E:  BCF    03.5
189F:  CALL   268
18A0:  BSF    0A.4
18A1:  BSF    0A.3
....................    LCD_PutChar('T'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('C'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('H'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('%'); 
18A2:  MOVLW  54
18A3:  BSF    03.5
18A4:  MOVWF  2A
18A5:  BCF    0A.4
18A6:  BCF    0A.3
18A7:  BCF    03.5
18A8:  CALL   26F
18A9:  BSF    0A.4
18AA:  BSF    0A.3
18AB:  MOVLW  3A
18AC:  BSF    03.5
18AD:  MOVWF  2A
18AE:  BCF    0A.4
18AF:  BCF    0A.3
18B0:  BCF    03.5
18B1:  CALL   26F
18B2:  BSF    0A.4
18B3:  BSF    0A.3
18B4:  MOVLW  20
18B5:  BSF    03.5
18B6:  MOVWF  2A
18B7:  BCF    0A.4
18B8:  BCF    0A.3
18B9:  BCF    03.5
18BA:  CALL   26F
18BB:  BSF    0A.4
18BC:  BSF    0A.3
18BD:  MOVLW  20
18BE:  BSF    03.5
18BF:  MOVWF  2A
18C0:  BCF    0A.4
18C1:  BCF    0A.3
18C2:  BCF    03.5
18C3:  CALL   26F
18C4:  BSF    0A.4
18C5:  BSF    0A.3
18C6:  MOVLW  43
18C7:  BSF    03.5
18C8:  MOVWF  2A
18C9:  BCF    0A.4
18CA:  BCF    0A.3
18CB:  BCF    03.5
18CC:  CALL   26F
18CD:  BSF    0A.4
18CE:  BSF    0A.3
18CF:  MOVLW  20
18D0:  BSF    03.5
18D1:  MOVWF  2A
18D2:  BCF    0A.4
18D3:  BCF    0A.3
18D4:  BCF    03.5
18D5:  CALL   26F
18D6:  BSF    0A.4
18D7:  BSF    0A.3
18D8:  MOVLW  20
18D9:  BSF    03.5
18DA:  MOVWF  2A
18DB:  BCF    0A.4
18DC:  BCF    0A.3
18DD:  BCF    03.5
18DE:  CALL   26F
18DF:  BSF    0A.4
18E0:  BSF    0A.3
18E1:  MOVLW  20
18E2:  BSF    03.5
18E3:  MOVWF  2A
18E4:  BCF    0A.4
18E5:  BCF    0A.3
18E6:  BCF    03.5
18E7:  CALL   26F
18E8:  BSF    0A.4
18E9:  BSF    0A.3
18EA:  MOVLW  48
18EB:  BSF    03.5
18EC:  MOVWF  2A
18ED:  BCF    0A.4
18EE:  BCF    0A.3
18EF:  BCF    03.5
18F0:  CALL   26F
18F1:  BSF    0A.4
18F2:  BSF    0A.3
18F3:  MOVLW  3A
18F4:  BSF    03.5
18F5:  MOVWF  2A
18F6:  BCF    0A.4
18F7:  BCF    0A.3
18F8:  BCF    03.5
18F9:  CALL   26F
18FA:  BSF    0A.4
18FB:  BSF    0A.3
18FC:  MOVLW  20
18FD:  BSF    03.5
18FE:  MOVWF  2A
18FF:  BCF    0A.4
1900:  BCF    0A.3
1901:  BCF    03.5
1902:  CALL   26F
1903:  BSF    0A.4
1904:  BSF    0A.3
1905:  MOVLW  20
1906:  BSF    03.5
1907:  MOVWF  2A
1908:  BCF    0A.4
1909:  BCF    0A.3
190A:  BCF    03.5
190B:  CALL   26F
190C:  BSF    0A.4
190D:  BSF    0A.3
190E:  MOVLW  25
190F:  BSF    03.5
1910:  MOVWF  2A
1911:  BCF    0A.4
1912:  BCF    0A.3
1913:  BCF    03.5
1914:  CALL   26F
1915:  BSF    0A.4
1916:  BSF    0A.3
....................    LCD_SetPosition(LINE_2); 
1917:  MOVLW  C0
1918:  BSF    03.5
1919:  MOVWF  20
191A:  BCF    0A.4
191B:  BCF    0A.3
191C:  BCF    03.5
191D:  CALL   268
191E:  BSF    0A.4
191F:  BSF    0A.3
....................    LCD_PutChar('H'); LCD_PutChar('R'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('b'); LCD_PutChar('p'); LCD_PutChar('m'); 
1920:  MOVLW  48
1921:  BSF    03.5
1922:  MOVWF  2A
1923:  BCF    0A.4
1924:  BCF    0A.3
1925:  BCF    03.5
1926:  CALL   26F
1927:  BSF    0A.4
1928:  BSF    0A.3
1929:  MOVLW  52
192A:  BSF    03.5
192B:  MOVWF  2A
192C:  BCF    0A.4
192D:  BCF    0A.3
192E:  BCF    03.5
192F:  CALL   26F
1930:  BSF    0A.4
1931:  BSF    0A.3
1932:  MOVLW  3A
1933:  BSF    03.5
1934:  MOVWF  2A
1935:  BCF    0A.4
1936:  BCF    0A.3
1937:  BCF    03.5
1938:  CALL   26F
1939:  BSF    0A.4
193A:  BSF    0A.3
193B:  MOVLW  20
193C:  BSF    03.5
193D:  MOVWF  2A
193E:  BCF    0A.4
193F:  BCF    0A.3
1940:  BCF    03.5
1941:  CALL   26F
1942:  BSF    0A.4
1943:  BSF    0A.3
1944:  MOVLW  20
1945:  BSF    03.5
1946:  MOVWF  2A
1947:  BCF    0A.4
1948:  BCF    0A.3
1949:  BCF    03.5
194A:  CALL   26F
194B:  BSF    0A.4
194C:  BSF    0A.3
194D:  MOVLW  20
194E:  BSF    03.5
194F:  MOVWF  2A
1950:  BCF    0A.4
1951:  BCF    0A.3
1952:  BCF    03.5
1953:  CALL   26F
1954:  BSF    0A.4
1955:  BSF    0A.3
1956:  MOVLW  62
1957:  BSF    03.5
1958:  MOVWF  2A
1959:  BCF    0A.4
195A:  BCF    0A.3
195B:  BCF    03.5
195C:  CALL   26F
195D:  BSF    0A.4
195E:  BSF    0A.3
195F:  MOVLW  70
1960:  BSF    03.5
1961:  MOVWF  2A
1962:  BCF    0A.4
1963:  BCF    0A.3
1964:  BCF    03.5
1965:  CALL   26F
1966:  BSF    0A.4
1967:  BSF    0A.3
1968:  MOVLW  6D
1969:  BSF    03.5
196A:  MOVWF  2A
196B:  BCF    0A.4
196C:  BCF    0A.3
196D:  BCF    03.5
196E:  CALL   26F
196F:  BSF    0A.4
1970:  BSF    0A.3
....................    LCD_SetPosition(LINE_3); 
1971:  MOVLW  90
1972:  BSF    03.5
1973:  MOVWF  20
1974:  BCF    0A.4
1975:  BCF    0A.3
1976:  BCF    03.5
1977:  CALL   268
1978:  BSF    0A.4
1979:  BSF    0A.3
....................    LCD_PutChar('S'); LCD_PutChar('p'); LCD_PutChar('O'); LCD_PutChar('2'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('%'); 
197A:  MOVLW  53
197B:  BSF    03.5
197C:  MOVWF  2A
197D:  BCF    0A.4
197E:  BCF    0A.3
197F:  BCF    03.5
1980:  CALL   26F
1981:  BSF    0A.4
1982:  BSF    0A.3
1983:  MOVLW  70
1984:  BSF    03.5
1985:  MOVWF  2A
1986:  BCF    0A.4
1987:  BCF    0A.3
1988:  BCF    03.5
1989:  CALL   26F
198A:  BSF    0A.4
198B:  BSF    0A.3
198C:  MOVLW  4F
198D:  BSF    03.5
198E:  MOVWF  2A
198F:  BCF    0A.4
1990:  BCF    0A.3
1991:  BCF    03.5
1992:  CALL   26F
1993:  BSF    0A.4
1994:  BSF    0A.3
1995:  MOVLW  32
1996:  BSF    03.5
1997:  MOVWF  2A
1998:  BCF    0A.4
1999:  BCF    0A.3
199A:  BCF    03.5
199B:  CALL   26F
199C:  BSF    0A.4
199D:  BSF    0A.3
199E:  MOVLW  3A
199F:  BSF    03.5
19A0:  MOVWF  2A
19A1:  BCF    0A.4
19A2:  BCF    0A.3
19A3:  BCF    03.5
19A4:  CALL   26F
19A5:  BSF    0A.4
19A6:  BSF    0A.3
19A7:  MOVLW  20
19A8:  BSF    03.5
19A9:  MOVWF  2A
19AA:  BCF    0A.4
19AB:  BCF    0A.3
19AC:  BCF    03.5
19AD:  CALL   26F
19AE:  BSF    0A.4
19AF:  BSF    0A.3
19B0:  MOVLW  20
19B1:  BSF    03.5
19B2:  MOVWF  2A
19B3:  BCF    0A.4
19B4:  BCF    0A.3
19B5:  BCF    03.5
19B6:  CALL   26F
19B7:  BSF    0A.4
19B8:  BSF    0A.3
19B9:  MOVLW  20
19BA:  BSF    03.5
19BB:  MOVWF  2A
19BC:  BCF    0A.4
19BD:  BCF    0A.3
19BE:  BCF    03.5
19BF:  CALL   26F
19C0:  BSF    0A.4
19C1:  BSF    0A.3
19C2:  MOVLW  25
19C3:  BSF    03.5
19C4:  MOVWF  2A
19C5:  BCF    0A.4
19C6:  BCF    0A.3
19C7:  BCF    03.5
19C8:  CALL   26F
19C9:  BSF    0A.4
19CA:  BSF    0A.3
....................    LCD_SetPosition(LINE_4); 
19CB:  MOVLW  D0
19CC:  BSF    03.5
19CD:  MOVWF  20
19CE:  BCF    0A.4
19CF:  BCF    0A.3
19D0:  BCF    03.5
19D1:  CALL   268
19D2:  BSF    0A.4
19D3:  BSF    0A.3
....................    LCD_PutChar('W'); LCD_PutChar('e'); LCD_PutChar('i'); LCD_PutChar('g'); LCD_PutChar('h'); LCD_PutChar('t'); LCD_PutChar(':'); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar(' '); LCD_PutChar('g'); 
19D4:  MOVLW  57
19D5:  BSF    03.5
19D6:  MOVWF  2A
19D7:  BCF    0A.4
19D8:  BCF    0A.3
19D9:  BCF    03.5
19DA:  CALL   26F
19DB:  BSF    0A.4
19DC:  BSF    0A.3
19DD:  MOVLW  65
19DE:  BSF    03.5
19DF:  MOVWF  2A
19E0:  BCF    0A.4
19E1:  BCF    0A.3
19E2:  BCF    03.5
19E3:  CALL   26F
19E4:  BSF    0A.4
19E5:  BSF    0A.3
19E6:  MOVLW  69
19E7:  BSF    03.5
19E8:  MOVWF  2A
19E9:  BCF    0A.4
19EA:  BCF    0A.3
19EB:  BCF    03.5
19EC:  CALL   26F
19ED:  BSF    0A.4
19EE:  BSF    0A.3
19EF:  MOVLW  67
19F0:  BSF    03.5
19F1:  MOVWF  2A
19F2:  BCF    0A.4
19F3:  BCF    0A.3
19F4:  BCF    03.5
19F5:  CALL   26F
19F6:  BSF    0A.4
19F7:  BSF    0A.3
19F8:  MOVLW  68
19F9:  BSF    03.5
19FA:  MOVWF  2A
19FB:  BCF    0A.4
19FC:  BCF    0A.3
19FD:  BCF    03.5
19FE:  CALL   26F
19FF:  BSF    0A.4
1A00:  BSF    0A.3
1A01:  MOVLW  74
1A02:  BSF    03.5
1A03:  MOVWF  2A
1A04:  BCF    0A.4
1A05:  BCF    0A.3
1A06:  BCF    03.5
1A07:  CALL   26F
1A08:  BSF    0A.4
1A09:  BSF    0A.3
1A0A:  MOVLW  3A
1A0B:  BSF    03.5
1A0C:  MOVWF  2A
1A0D:  BCF    0A.4
1A0E:  BCF    0A.3
1A0F:  BCF    03.5
1A10:  CALL   26F
1A11:  BSF    0A.4
1A12:  BSF    0A.3
1A13:  MOVLW  20
1A14:  BSF    03.5
1A15:  MOVWF  2A
1A16:  BCF    0A.4
1A17:  BCF    0A.3
1A18:  BCF    03.5
1A19:  CALL   26F
1A1A:  BSF    0A.4
1A1B:  BSF    0A.3
1A1C:  MOVLW  20
1A1D:  BSF    03.5
1A1E:  MOVWF  2A
1A1F:  BCF    0A.4
1A20:  BCF    0A.3
1A21:  BCF    03.5
1A22:  CALL   26F
1A23:  BSF    0A.4
1A24:  BSF    0A.3
1A25:  MOVLW  20
1A26:  BSF    03.5
1A27:  MOVWF  2A
1A28:  BCF    0A.4
1A29:  BCF    0A.3
1A2A:  BCF    03.5
1A2B:  CALL   26F
1A2C:  BSF    0A.4
1A2D:  BSF    0A.3
1A2E:  MOVLW  20
1A2F:  BSF    03.5
1A30:  MOVWF  2A
1A31:  BCF    0A.4
1A32:  BCF    0A.3
1A33:  BCF    03.5
1A34:  CALL   26F
1A35:  BSF    0A.4
1A36:  BSF    0A.3
1A37:  MOVLW  20
1A38:  BSF    03.5
1A39:  MOVWF  2A
1A3A:  BCF    0A.4
1A3B:  BCF    0A.3
1A3C:  BCF    03.5
1A3D:  CALL   26F
1A3E:  BSF    0A.4
1A3F:  BSF    0A.3
1A40:  MOVLW  67
1A41:  BSF    03.5
1A42:  MOVWF  2A
1A43:  BCF    0A.4
1A44:  BCF    0A.3
1A45:  BCF    03.5
1A46:  CALL   26F
1A47:  BSF    0A.4
1A48:  BSF    0A.3
....................  
....................    // Independent timing counters 
....................    int16 max30102_counter = 0; 
....................    int16 dht11_counter = 0; 
....................    int16 hx711_counter = 0; 
....................    int16 display_counter = 0; 
....................  
....................    unsigned int8 temp = 0; 
....................    unsigned int8 hum = 0; 
....................    int32 weight_grams = 0; 
1A49:  CLRF   5C
1A4A:  CLRF   5B
1A4B:  CLRF   5E
1A4C:  CLRF   5D
1A4D:  CLRF   60
1A4E:  CLRF   5F
1A4F:  CLRF   62
1A50:  CLRF   61
1A51:  CLRF   63
1A52:  CLRF   64
1A53:  CLRF   68
1A54:  CLRF   67
1A55:  CLRF   66
1A56:  CLRF   65
....................    // Assuming hr_value and spo2_value are global, declared in max30102.c/h 
....................    // extern unsigned int16 hr_value; 
....................    // extern unsigned int8 spo2_value; 
....................  
....................  
....................    while (TRUE) { 
....................       // --- Quá trình hi?u chu?n HX711 (ch? ch?y m?t l?n sau khi kh?i d?ng) --- 
....................       if (!calibrate_done) { 
1A57:  BTFSC  24.3
1A58:  GOTO   293
....................          hx711_tare(1); // Bu?c 1: Tare cân khi không có gì trên dó 
1A59:  MOVLW  01
1A5A:  MOVWF  6D
1A5B:  BCF    0A.4
1A5C:  BCF    0A.3
1A5D:  CALL   25F
1A5E:  BSF    0A.4
1A5F:  BSF    0A.3
....................          delay_ms(2000); // Ch? 2 giây d? cân ?n d?nh sau khi tare 
1A60:  MOVLW  08
1A61:  MOVWF  6D
1A62:  MOVLW  FA
1A63:  BSF    03.5
1A64:  MOVWF  2C
1A65:  BCF    0A.4
1A66:  BCF    0A.3
1A67:  BCF    03.5
1A68:  CALL   02E
1A69:  BSF    0A.4
1A6A:  BSF    0A.3
1A6B:  DECFSZ 6D,F
1A6C:  GOTO   262
....................           
....................          // Ch? m?t kho?ng th?i gian d? d? ngu?i dùng d?t v?t m?u lên 
....................          // KHÔNG CÓ THÔNG BÁO TRÊN LCD, b?n ph?i t? d?t v?t m?u. 
....................          // Ð?M B?O B?N Ð?T V?T KNOWN_WEIGHT_FOR_CALIBRATION TRU?C KHI H?T TH?I GIAN NÀY 
....................          delay_ms(5000); // Ví d?: ch? 5 giây 
1A6D:  MOVLW  14
1A6E:  MOVWF  6D
1A6F:  MOVLW  FA
1A70:  BSF    03.5
1A71:  MOVWF  2C
1A72:  BCF    0A.4
1A73:  BCF    0A.3
1A74:  BCF    03.5
1A75:  CALL   02E
1A76:  BSF    0A.4
1A77:  BSF    0A.3
1A78:  DECFSZ 6D,F
1A79:  GOTO   26F
....................  
....................          hx711_calibrate(KNOWN_WEIGHT_FOR_CALIBRATION); // Bu?c 2: Hi?u chu?n v?i v?t m?u dã bi?t 
1A7A:  CLRF   70
1A7B:  CLRF   6F
1A7C:  MOVLW  78
1A7D:  MOVWF  6E
1A7E:  MOVLW  83
1A7F:  MOVWF  6D
1A80:  BCF    0A.4
1A81:  BCF    0A.3
1A82:  GOTO   3A3
1A83:  BSF    0A.4
1A84:  BSF    0A.3
....................          delay_ms(1000); // Ch? 1 giây sau khi hi?u chu?n 
1A85:  MOVLW  04
1A86:  MOVWF  6D
1A87:  MOVLW  FA
1A88:  BSF    03.5
1A89:  MOVWF  2C
1A8A:  BCF    0A.4
1A8B:  BCF    0A.3
1A8C:  BCF    03.5
1A8D:  CALL   02E
1A8E:  BSF    0A.4
1A8F:  BSF    0A.3
1A90:  DECFSZ 6D,F
1A91:  GOTO   287
....................           
....................          calibrate_done = TRUE; // Ð?t c? d? ch? ch?y m?t l?n 
1A92:  BSF    24.3
....................       } 
....................  
....................       // MAX30102 - Ð?c m?i 5ms (max30102_counter % 1) 
....................       if (max30102_counter == 0) { 
1A93:  MOVF   5B,F
1A94:  BTFSS  03.2
1A95:  GOTO   29E
1A96:  MOVF   5C,F
1A97:  BTFSS  03.2
1A98:  GOTO   29E
....................          max30102_read_and_display(); 
1A99:  BCF    0A.4
1A9A:  BCF    0A.3
1A9B:  GOTO   422
1A9C:  BSF    0A.4
1A9D:  BSF    0A.3
....................       } 
....................       max30102_counter = (max30102_counter + 1) % 1; 
1A9E:  MOVLW  01
1A9F:  ADDWF  5B,W
1AA0:  MOVWF  6D
1AA1:  MOVF   5C,W
1AA2:  MOVWF  6E
1AA3:  BTFSC  03.0
1AA4:  INCF   6E,F
1AA5:  CLRF   5B
1AA6:  CLRF   5C
....................  
....................       // DHT11 
....................       if (dht11_counter == 0) { 
1AA7:  MOVF   5D,F
1AA8:  BTFSS  03.2
1AA9:  GOTO   2B8
1AAA:  MOVF   5E,F
1AAB:  BTFSS  03.2
1AAC:  GOTO   2B8
....................          dht11_read(&temp, &hum); 
1AAD:  CLRF   6E
1AAE:  MOVLW  63
1AAF:  MOVWF  6D
1AB0:  CLRF   70
1AB1:  MOVLW  64
1AB2:  MOVWF  6F
1AB3:  BCF    0A.4
1AB4:  BCF    0A.3
1AB5:  GOTO   708
1AB6:  BSF    0A.4
1AB7:  BSF    0A.3
....................       } 
....................       dht11_counter = (dht11_counter + 1) % DHT11_INTERVAL_TICKS; 
1AB8:  MOVLW  01
1AB9:  ADDWF  5D,W
1ABA:  MOVWF  6D
1ABB:  MOVF   5E,W
1ABC:  MOVWF  6E
1ABD:  BTFSC  03.0
1ABE:  INCF   6E,F
1ABF:  MOVF   6E,W
1AC0:  MOVWF  70
1AC1:  MOVF   6D,W
1AC2:  MOVWF  6F
1AC3:  CLRF   72
1AC4:  MOVLW  64
1AC5:  MOVWF  71
1AC6:  BCF    0A.4
1AC7:  CALL   000
1AC8:  BSF    0A.4
1AC9:  MOVF   77,W
1ACA:  MOVWF  5D
1ACB:  MOVF   7A,W
1ACC:  MOVWF  5E
....................  
....................       // HX711 
....................       if (hx711_counter == 0) { 
1ACD:  MOVF   5F,F
1ACE:  BTFSS  03.2
1ACF:  GOTO   348
1AD0:  MOVF   60,F
1AD1:  BTFSS  03.2
1AD2:  GOTO   348
....................          float current_weight_float = hx711_get_units(1); // The '1' argument is unused in hx711.h 
1AD3:  MOVLW  01
1AD4:  MOVWF  6D
1AD5:  BCF    0A.4
1AD6:  GOTO   025
1AD7:  BSF    0A.4
1AD8:  MOVF   7A,W
1AD9:  MOVWF  6C
1ADA:  MOVF   79,W
1ADB:  MOVWF  6B
1ADC:  MOVF   78,W
1ADD:  MOVWF  6A
1ADE:  MOVF   77,W
1ADF:  MOVWF  69
....................          // Round to nearest integer gram for display. Add 0.5 before casting for proper rounding. 
....................          if (current_weight_float >= 0) { 
1AE0:  BSF    03.5
1AE1:  CLRF   27
1AE2:  CLRF   26
1AE3:  CLRF   25
1AE4:  CLRF   24
1AE5:  BCF    03.5
1AE6:  MOVF   6C,W
1AE7:  BSF    03.5
1AE8:  MOVWF  2B
1AE9:  BCF    03.5
1AEA:  MOVF   6B,W
1AEB:  BSF    03.5
1AEC:  MOVWF  2A
1AED:  BCF    03.5
1AEE:  MOVF   6A,W
1AEF:  BSF    03.5
1AF0:  MOVWF  29
1AF1:  BCF    03.5
1AF2:  MOVF   69,W
1AF3:  BSF    03.5
1AF4:  MOVWF  28
1AF5:  BCF    0A.4
1AF6:  BCF    0A.3
1AF7:  BCF    03.5
1AF8:  CALL   277
1AF9:  BSF    0A.4
1AFA:  BSF    0A.3
1AFB:  BTFSC  03.0
1AFC:  GOTO   2FF
1AFD:  BTFSS  03.2
1AFE:  GOTO   324
....................             weight_grams = (int32)(current_weight_float + 0.5f); 
1AFF:  BCF    03.1
1B00:  MOVF   6C,W
1B01:  MOVWF  70
1B02:  MOVF   6B,W
1B03:  MOVWF  6F
1B04:  MOVF   6A,W
1B05:  MOVWF  6E
1B06:  MOVF   69,W
1B07:  MOVWF  6D
1B08:  CLRF   74
1B09:  CLRF   73
1B0A:  CLRF   72
1B0B:  MOVLW  7E
1B0C:  MOVWF  71
1B0D:  BCF    0A.4
1B0E:  CALL   2A4
1B0F:  BSF    0A.4
1B10:  MOVF   7A,W
1B11:  MOVWF  70
1B12:  MOVF   79,W
1B13:  MOVWF  6F
1B14:  MOVF   78,W
1B15:  MOVWF  6E
1B16:  MOVF   77,W
1B17:  MOVWF  6D
1B18:  BCF    0A.4
1B19:  CALL   3FD
1B1A:  BSF    0A.4
1B1B:  MOVF   7A,W
1B1C:  MOVWF  68
1B1D:  MOVF   79,W
1B1E:  MOVWF  67
1B1F:  MOVF   78,W
1B20:  MOVWF  66
1B21:  MOVF   77,W
1B22:  MOVWF  65
....................          } else { 
1B23:  GOTO   348
....................             // Your hx711.h already attempts to make corrected_weight >= 0. 
....................             // This handles any potential case where it might still be slightly negative. 
....................             weight_grams = (int32)(current_weight_float - 0.5f); // Proper rounding for negative numbers 
1B24:  BSF    03.1
1B25:  MOVF   6C,W
1B26:  MOVWF  70
1B27:  MOVF   6B,W
1B28:  MOVWF  6F
1B29:  MOVF   6A,W
1B2A:  MOVWF  6E
1B2B:  MOVF   69,W
1B2C:  MOVWF  6D
1B2D:  CLRF   74
1B2E:  CLRF   73
1B2F:  CLRF   72
1B30:  MOVLW  7E
1B31:  MOVWF  71
1B32:  BCF    0A.4
1B33:  CALL   2A4
1B34:  BSF    0A.4
1B35:  MOVF   7A,W
1B36:  MOVWF  70
1B37:  MOVF   79,W
1B38:  MOVWF  6F
1B39:  MOVF   78,W
1B3A:  MOVWF  6E
1B3B:  MOVF   77,W
1B3C:  MOVWF  6D
1B3D:  BCF    0A.4
1B3E:  CALL   3FD
1B3F:  BSF    0A.4
1B40:  MOVF   7A,W
1B41:  MOVWF  68
1B42:  MOVF   79,W
1B43:  MOVWF  67
1B44:  MOVF   78,W
1B45:  MOVWF  66
1B46:  MOVF   77,W
1B47:  MOVWF  65
....................          } 
....................          // Ensure weight_grams does not go negative if hx711.h logic didn't catch it perfectly. 
....................          // Or if you strictly want non-negative display: 
....................          if (weight_grams < 0) { 
....................             weight_grams = 0; 
....................          } 
....................       } 
....................       hx711_counter = (hx711_counter + 1) % HX711_INTERVAL_TICKS; 
1B48:  MOVLW  01
1B49:  ADDWF  5F,W
1B4A:  MOVWF  6D
1B4B:  MOVF   60,W
1B4C:  MOVWF  6E
1B4D:  BTFSC  03.0
1B4E:  INCF   6E,F
1B4F:  MOVF   6E,W
1B50:  MOVWF  70
1B51:  MOVF   6D,W
1B52:  MOVWF  6F
1B53:  CLRF   72
1B54:  MOVLW  32
1B55:  MOVWF  71
1B56:  BCF    0A.4
1B57:  CALL   000
1B58:  BSF    0A.4
1B59:  MOVF   77,W
1B5A:  MOVWF  5F
1B5B:  MOVF   7A,W
1B5C:  MOVWF  60
....................  
....................       // Display update and UART transmission 
....................       if (display_counter == 0) { 
1B5D:  MOVF   61,F
1B5E:  BTFSS  03.2
1B5F:  GOTO   3BF
1B60:  MOVF   62,F
1B61:  BTFSS  03.2
1B62:  GOTO   3BF
....................          display_number(temp, LINE_1 + 2, 2); 
1B63:  CLRF   70
1B64:  CLRF   6F
1B65:  CLRF   6E
1B66:  MOVF   63,W
1B67:  MOVWF  6D
1B68:  MOVLW  82
1B69:  MOVWF  71
1B6A:  MOVLW  02
1B6B:  MOVWF  72
1B6C:  BCF    0A.3
1B6D:  CALL   000
1B6E:  BSF    0A.3
....................          display_number(hum, LINE_1 + 11, 2); 
1B6F:  CLRF   70
1B70:  CLRF   6F
1B71:  CLRF   6E
1B72:  MOVF   64,W
1B73:  MOVWF  6D
1B74:  MOVLW  8B
1B75:  MOVWF  71
1B76:  MOVLW  02
1B77:  MOVWF  72
1B78:  BCF    0A.3
1B79:  CALL   000
1B7A:  BSF    0A.3
....................          display_number(hr_value, LINE_2 + 3, 3); 
1B7B:  CLRF   70
1B7C:  CLRF   6F
1B7D:  MOVF   27,W
1B7E:  MOVWF  6E
1B7F:  MOVF   26,W
1B80:  MOVWF  6D
1B81:  MOVLW  C3
1B82:  MOVWF  71
1B83:  MOVLW  03
1B84:  MOVWF  72
1B85:  BCF    0A.3
1B86:  CALL   000
1B87:  BSF    0A.3
....................          display_number(spo2_value, LINE_3 + 5, 3); 
1B88:  CLRF   70
1B89:  CLRF   6F
1B8A:  MOVF   29,W
1B8B:  MOVWF  6E
1B8C:  MOVF   28,W
1B8D:  MOVWF  6D
1B8E:  MOVLW  95
1B8F:  MOVWF  71
1B90:  MOVLW  03
1B91:  MOVWF  72
1B92:  BCF    0A.3
1B93:  CALL   000
1B94:  BSF    0A.3
....................          display_number(weight_grams, LINE_4 + 7, 5); 
1B95:  MOVF   68,W
1B96:  MOVWF  70
1B97:  MOVF   67,W
1B98:  MOVWF  6F
1B99:  MOVF   66,W
1B9A:  MOVWF  6E
1B9B:  MOVF   65,W
1B9C:  MOVWF  6D
1B9D:  MOVLW  D7
1B9E:  MOVWF  71
1B9F:  MOVLW  05
1BA0:  MOVWF  72
1BA1:  BCF    0A.3
1BA2:  CALL   000
1BA3:  BSF    0A.3
....................          uart_send_data(temp, hum, hr_value, spo2_value, weight_grams); 
1BA4:  MOVF   63,W
1BA5:  MOVWF  6D
1BA6:  MOVF   64,W
1BA7:  MOVWF  6E
1BA8:  CLRF   72
1BA9:  CLRF   71
1BAA:  MOVF   27,W
1BAB:  MOVWF  70
1BAC:  MOVF   26,W
1BAD:  MOVWF  6F
1BAE:  CLRF   76
1BAF:  CLRF   75
1BB0:  MOVF   29,W
1BB1:  MOVWF  74
1BB2:  MOVF   28,W
1BB3:  MOVWF  73
1BB4:  MOVF   68,W
1BB5:  MOVWF  7E
1BB6:  MOVF   67,W
1BB7:  MOVWF  7D
1BB8:  MOVF   66,W
1BB9:  MOVWF  7C
1BBA:  MOVF   65,W
1BBB:  MOVWF  7B
1BBC:  BCF    0A.4
1BBD:  GOTO   548
1BBE:  BSF    0A.4
....................       } 
....................       display_counter = (display_counter + 1) % DISPLAY_UART_INTERVAL_TICKS; 
1BBF:  MOVLW  01
1BC0:  ADDWF  61,W
1BC1:  MOVWF  6D
1BC2:  MOVF   62,W
1BC3:  MOVWF  6E
1BC4:  BTFSC  03.0
1BC5:  INCF   6E,F
1BC6:  MOVF   6E,W
1BC7:  MOVWF  70
1BC8:  MOVF   6D,W
1BC9:  MOVWF  6F
1BCA:  CLRF   72
1BCB:  MOVLW  32
1BCC:  MOVWF  71
1BCD:  BCF    0A.4
1BCE:  CALL   000
1BCF:  BSF    0A.4
1BD0:  MOVF   77,W
1BD1:  MOVWF  61
1BD2:  MOVF   7A,W
1BD3:  MOVWF  62
....................  
....................       delay_ms(5); // Base 5ms cycle 
1BD4:  MOVLW  05
1BD5:  BSF    03.5
1BD6:  MOVWF  2C
1BD7:  BCF    0A.4
1BD8:  BCF    0A.3
1BD9:  BCF    03.5
1BDA:  CALL   02E
1BDB:  BSF    0A.4
1BDC:  BSF    0A.3
1BDD:  GOTO   257
....................    } 
.................... } 
1BDE:  SLEEP

Configuration Fuses:
   Word  1: 2F42   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
